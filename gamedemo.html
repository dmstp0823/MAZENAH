<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ì˜¨ë¼ì¸ ìˆœìœ„ ê²½ìŸ! ë¬¼ì²´ í”¼í•˜ê¸°</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { display: block; cursor: pointer; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <audio id="bgm" src="./Love3.mp3" loop></audio>

    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

    <script>
        // ==================================================================
        // ì—¬ê¸°ì— Firebaseì—ì„œ ë³µì‚¬í•œ ë‚˜ë§Œì˜ firebaseConfig ì½”ë“œë¥¼ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.
        // ==================================================================
        const firebaseConfig = {
            apiKey: "YOUR_API_KEY",
            authDomain: "YOUR_AUTH_DOMAIN",
            projectId: "YOUR_PROJECT_ID",
            storageBucket: "YOUR_STORAGE_BUCKET",
            messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
            appId: "YOUR_APP_ID"
        };
        // ==================================================================

        // Firebase ì•± ì´ˆê¸°í™”
        let db;
        try {
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
        } catch (e) {
            console.error("Firebase ì´ˆê¸°í™” ì˜¤ë¥˜:", e);
            alert("Firebase ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. firebaseConfigë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.");
        }
        
        const leaderboardCollection = db ? db.collection('leaderboard') : null;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const bgm = document.getElementById('bgm');
        bgm.volume = 0.5;

        // --- 1. ìºë¦­í„° ë°ì´í„°ì— ì´ë¯¸ì§€ ê²½ë¡œ ì¶”ê°€ ---
        const characters = [
            { id: 1, name: 'ë¸”ë£¨', color: '#3498db', speed: 9, imgSrc: './char1.png', img: null },
            { id: 2, name: 'ê·¸ë¦°', color: '#2ecc71', speed: 7, imgSrc: './char2.png', img: null },
            { id: 3, name: 'í¼í”Œ', color: '#8e44ad', speed: 8, imgSrc: './char3.png', img: null }
        ];
        let selectedCharacterId = 1;
        
        let uiBoxes = {};
        let startScreenState = 'main'; 

        // --- 2. ìˆœìœ„í‘œ ìŠ¤í¬ë¡¤ì„ ìœ„í•œ ë³€ìˆ˜ ì¶”ê°€ ---
        let leaderboardScrollY = 0;
        let leaderboardTotalHeight = 0;
        let isDragging = false;
        let lastTouchY = 0;

        let player, objects, score, spawnTimer, targetX;
        let gameState = 'loading'; // ë¡œë”© ìƒíƒœ ì¶”ê°€
        let lastTime = 0;
        let gameSpeedMultiplier = 1;

        let feverScore = 0, isFeverTime = false, feverTimer = 0;
        const FEVER_DURATION = 5000;
        const FEVER_TRIGGER_COUNT = 10;
        const BASE_SPAWN_INTERVAL = 450;
        const FEVER_SPAWN_INTERVAL = 120;
        let pauseButtonBox = {};

        // --- 3. ì´ë¯¸ì§€ ë¯¸ë¦¬ ë¶ˆëŸ¬ì˜¤ê¸° í•¨ìˆ˜ ---
        function loadImages() {
            let promises = characters.map(char => {
                return new Promise((resolve, reject) => {
                    char.img = new Image();
                    char.img.src = char.imgSrc;
                    char.img.onload = () => resolve();
                    char.img.onerror = () => reject(`ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: ${char.imgSrc}`);
                });
            });
            return Promise.all(promises);
        }

        function init() {
            const selectedCharacter = characters.find(c => c.id === selectedCharacterId);
            player = {
                width: 60, height: 60, // ì´ë¯¸ì§€ í¬ê¸°ì— ë§ê²Œ ì¡°ì ˆ
                x: canvas.width / 2 - 30,
                y: canvas.height - 120, // âœ¨ ìºë¦­í„° ì¸ì‹ ìœ„ì¹˜ ìœ„ë¡œ ì¡°ì •
                speed: selectedCharacter.speed,
                img: selectedCharacter.img, // ìºë¦­í„° ì´ë¯¸ì§€
                dx: 0
            };
            
            targetX = player.x; objects = []; score = 0; spawnTimer = 0;
            gameSpeedMultiplier = 1; feverScore = 0; isFeverTime = false; feverTimer = 0;
            gameState = 'playing';
            bgm.currentTime = 0;
            bgm.play();
        }
        
        // --- 4. í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸° í•¨ìˆ˜ ìˆ˜ì • (ì´ë¯¸ì§€ ì‚¬ìš©) ---
        function drawPlayer() {
            if (player && player.img) {
                ctx.drawImage(player.img, player.x, player.y, player.width, player.height);
            }
        }
        
        // --- 5. ìˆœìœ„í‘œ ìŠ¤í¬ë¡¤ ë° UI ìˆ˜ì • ---
        async function drawLeaderboardScreen() {
            const leaderboard = await loadLeaderboard();
            ctx.fillStyle = '#34495e'; ctx.font = 'bold 32px Arial'; ctx.textAlign = 'center';
            ctx.fillText('ğŸ† Top 10 ğŸ†', canvas.width / 2, 50);

            const listStartY = 100;
            const listHeight = canvas.height - 200;
            const boxWidth = 300, boxHeight = 40, gap = 10;
            leaderboardTotalHeight = leaderboard.length * (boxHeight + gap) - gap;

            // ìŠ¤í¬ë¡¤ ë²”ìœ„ ì œí•œ
            const maxScroll = 0;
            const minScroll = -(leaderboardTotalHeight - listHeight);
            if (leaderboardScrollY > maxScroll) leaderboardScrollY = maxScroll;
            if (leaderboardScrollY < minScroll && leaderboardTotalHeight > listHeight) leaderboardScrollY = minScroll;
            
            // ìŠ¤í¬ë¡¤ ì˜ì—­ í´ë¦¬í•‘ (ë²—ì–´ë‚˜ë©´ ì•ˆë³´ì´ê²Œ)
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, listStartY, canvas.width, listHeight);
            ctx.clip();

            if (leaderboard.length === 0) {
                ctx.font = '20px Arial';
                ctx.fillText('ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤!', canvas.width / 2, listStartY + 50);
            } else {
                leaderboard.forEach((entry, index) => {
                    const boxY = listStartY + index * (boxHeight + gap) + leaderboardScrollY;
                    ctx.fillStyle = index < 3 ? '#f1c40f' : '#bdc3c7';
                    ctx.fillRect((canvas.width - boxWidth) / 2, boxY, boxWidth, boxHeight);
                    ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 18px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(`${index + 1}.`, (canvas.width - boxWidth) / 2 + 20, boxY + 25);
                    ctx.textAlign = 'center';
                    ctx.fillText(entry.name, canvas.width / 2, boxY + 25);
                    ctx.textAlign = 'right';
                    ctx.fillText(entry.score, (canvas.width + boxWidth) / 2 - 20, boxY + 25);
                });
            }
            ctx.restore();

            // 'í™•ì¸' ë²„íŠ¼ìœ¼ë¡œ ë³€ê²½
            drawConfirmButton(canvas.height - 80);
        }

        function drawCharacterSelectScreen() {
            ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 32px Arial'; ctx.textAlign = 'center';
            ctx.fillText('ìºë¦­í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”', canvas.width / 2, canvas.height * 0.2);
            
            const boxWidth = 100, boxHeight = 100, gap = 20;
            const totalWidth = (boxWidth * characters.length) + (gap * (characters.length - 1));
            let startX = (canvas.width - totalWidth) / 2;
            uiBoxes.characterBoxes = [];
            characters.forEach(char => {
                const boxY = canvas.height * 0.4;
                if (char.id === selectedCharacterId) { ctx.fillStyle = 'orange'; ctx.fillRect(startX - 5, boxY - 5, boxWidth + 10, boxHeight + 10); }
                
                // ìºë¦­í„° ì‚¬ê°í˜• ëŒ€ì‹  ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
                if (char.img) {
                    ctx.drawImage(char.img, startX, boxY, boxWidth, boxHeight);
                } else {
                    ctx.fillStyle = char.color;
                    ctx.fillRect(startX, boxY, boxWidth, boxHeight);
                }

                ctx.fillStyle = '#2c3e50'; ctx.font = '20px Arial';
                ctx.fillText(char.name, startX + boxWidth / 2, boxY + boxHeight + 30);
                uiBoxes.characterBoxes.push({ id: char.id, x: startX, y: boxY, width: boxWidth, height: boxHeight });
                startX += boxWidth + gap;
            });
            drawConfirmButton(canvas.height * 0.85);
        }

        function drawConfirmButton(yPos) {
            const btnWidth = 150, btnHeight = 50;
            const btnX = (canvas.width - btnWidth) / 2;
            uiBoxes.confirmBtn = { x: btnX, y: yPos, width: btnWidth, height: btnHeight };
            ctx.fillStyle = '#2980b9'; ctx.fillRect(btnX, yPos, btnWidth, btnHeight);
            ctx.fillStyle = 'white'; ctx.font = 'bold 20px Arial';
            ctx.fillText('í™•ì¸', canvas.width / 2, yPos + 32);
        }
        
        // --- 6. ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¶”ê°€ ---
        function handleWheel(e) {
            if (gameState === 'startScreen' && startScreenState === 'leaderboard') {
                e.preventDefault();
                leaderboardScrollY -= e.deltaY * 0.5;
            }
        }

        async function handleInteractionStart(e) {
            e.preventDefault();
            const pos = getEventPos(e);
            if (gameState === 'startScreen') {
                if (startScreenState === 'main') {
                    // ... (ë©”ì¸ ë©”ë‰´ ë¡œì§)
                } else {
                    if (startScreenState === 'characterSelect') {
                        // ... (ìºë¦­í„° ì„ íƒ ë¡œì§)
                    }
                    // í™•ì¸ ë²„íŠ¼ í´ë¦­ ì‹œ ë©”ì¸ìœ¼ë¡œ
                    if (isInside(pos, uiBoxes.confirmBtn)) {
                        startScreenState = 'main';
                        leaderboardScrollY = 0; // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ì´ˆê¸°í™”
                    }
                    // ìˆœìœ„í‘œ í™”ë©´ì—ì„œ í„°ì¹˜ ì‹œì‘ (ìŠ¤í¬ë¡¤ìš©)
                    if (startScreenState === 'leaderboard') {
                        isDragging = true;
                        lastTouchY = pos.y;
                    }
                }
            } // ... (ì´í•˜ ë‹¤ë¥¸ ê²Œì„ ìƒíƒœ ë¡œì§)
        }

        function handleInteractionMove(e) {
            e.preventDefault();
            const pos = getEventPos(e);
            if (gameState === 'startScreen' && startScreenState === 'leaderboard' && isDragging) {
                const deltaY = pos.y - lastTouchY;
                leaderboardScrollY += deltaY;
                lastTouchY = pos.y;
            } else if (gameState === 'playing' && (e.buttons === 1 || e.touches)) {
                // ... (ê²Œì„ í”Œë ˆì´ ì¤‘ ì´ë™ ë¡œì§)
            }
        }
        
        function handleInteractionEnd(e) {
            isDragging = false;
        }

        // -------------------------------------------------------------------
        // ì•„ë˜ëŠ” í¸ì˜ë¥¼ ìœ„í•´ ì „ì²´ ì½”ë“œ(ìˆ˜ì •ë˜ì§€ ì•Šì€ ë¶€ë¶„ í¬í•¨)ë¥¼ ë‹¤ì‹œ ì²¨ë¶€í•©ë‹ˆë‹¤.
        // -------------------------------------------------------------------
        
        // --- ë‚˜ë¨¸ì§€ ëª¨ë“  í•¨ìˆ˜ë“¤ (ìˆ˜ì • ì—†ìŒ) ---
        async function loadLeaderboard() { if (!leaderboardCollection) return []; try { const snapshot = await leaderboardCollection.orderBy('score', 'desc').limit(10).get(); const leaderboard = []; snapshot.forEach(doc => { leaderboard.push(doc.data()); }); return leaderboard; } catch (error) { console.error("ìˆœìœ„í‘œ ë¡œë”© ì˜¤ë¥˜: ", error); return []; } }
        async function saveToLeaderboard(newScore, nickname) { if (!leaderboardCollection) return; try { await leaderboardCollection.add({ score: newScore, name: nickname }); } catch (error) { console.error("ìˆœìœ„í‘œ ì €ì¥ ì˜¤ë¥˜: ", error); } }
        function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.addEventListener('resize', resizeCanvas);
        document.addEventListener('visibilitychange', () => { if (document.hidden && gameState === 'playing') { gameState = 'paused'; bgm.pause(); } });
        function getEventPos(e) { const rect = canvas.getBoundingClientRect(); const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; return { x: clientX - rect.left, y: clientY - rect.top }; }
        async function handleInteractionStart(e) {
            e.preventDefault();
            const pos = getEventPos(e);
            if (gameState === 'startScreen') {
                if (startScreenState === 'main') {
                    if (isInside(pos, uiBoxes.charSelectBtn)) startScreenState = 'characterSelect';
                    else if (isInside(pos, uiBoxes.leaderboardBtn)) { leaderboardScrollY = 0; startScreenState = 'leaderboard'; }
                    else if (isInside(pos, uiBoxes.startBtn)) init();
                } else {
                    if (startScreenState === 'characterSelect') {
                        uiBoxes.characterBoxes.forEach(box => { if (isInside(pos, box)) selectedCharacterId = box.id; });
                    }
                    if (isInside(pos, uiBoxes.confirmBtn)) { startScreenState = 'main'; leaderboardScrollY = 0; }
                    if (startScreenState === 'leaderboard') { isDragging = true; lastTouchY = pos.y; }
                }
            } else if (gameState === 'playing') {
                if (isInside(pos, pauseButtonBox)) { gameState = 'paused'; bgm.pause(); }
                else { player.dx = 0; targetX = pos.x - player.width / 2; }
            } else if (gameState === 'paused') {
                gameState = 'playing'; bgm.play();
            } else if (gameState === 'gameOver') {
                const nickname = prompt(`ê²Œì„ ì˜¤ë²„!\nìµœì¢… ì ìˆ˜: ${score}\n\nìˆœìœ„ì— ë“±ë¡í•  ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”:`, '');
                if (nickname && nickname.trim() !== '') { await saveToLeaderboard(score, nickname.trim()); }
                gameState = 'startScreen'; startScreenState = 'main'; lastTime = 0;
            }
        }
        function handleInteractionMove(e) {
            e.preventDefault();
            const pos = getEventPos(e);
            if (gameState === 'startScreen' && startScreenState === 'leaderboard' && isDragging) {
                const deltaY = pos.y - lastTouchY;
                leaderboardScrollY += deltaY;
                lastTouchY = pos.y;
            } else if (gameState === 'playing' && (e.buttons === 1 || e.touches)) {
                player.dx = 0; targetX = pos.x - player.width / 2;
            }
        }
        canvas.addEventListener('wheel', handleWheel);
        canvas.addEventListener('touchend', handleInteractionEnd);
        canvas.addEventListener('mouseup', handleInteractionEnd);
        function drawMainMenu() { ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 48px Arial'; ctx.textAlign = 'center'; ctx.fillText('ë¬¼ì²´ í”¼í•˜ê¸° ê²Œì„', canvas.width / 2, canvas.height * 0.2); const btnWidth = 250, btnHeight = 60, gap = 30; const btnX = (canvas.width - btnWidth) / 2, startY = canvas.height * 0.4; uiBoxes.charSelectBtn = { x: btnX, y: startY, width: btnWidth, height: btnHeight }; ctx.fillStyle = '#2ecc71'; ctx.fillRect(btnX, startY, btnWidth, btnHeight); ctx.fillStyle = 'white'; ctx.font = 'bold 24px Arial'; ctx.fillText('ìºë¦­í„° ì„ íƒ', canvas.width / 2, startY + 38); uiBoxes.leaderboardBtn = { x: btnX, y: startY + btnHeight + gap, width: btnWidth, height: btnHeight }; ctx.fillStyle = '#e67e22'; ctx.fillRect(btnX, startY + btnHeight + gap, btnWidth, btnHeight); ctx.fillStyle = 'white'; ctx.fillText('ìˆœìœ„ ë³´ê¸°', canvas.width / 2, startY + btnHeight + gap + 38); uiBoxes.startBtn = { x: btnX, y: startY + (btnHeight + gap) * 2, width: btnWidth, height: btnHeight }; ctx.fillStyle = '#3498db'; ctx.fillRect(btnX, startY + (btnHeight + gap) * 2, btnWidth, btnHeight); ctx.fillStyle = 'white'; ctx.fillText('ê²Œì„ ì‹œì‘', canvas.width / 2, startY + (btnHeight + gap) * 2 + 38); }
        function isInside(pos, rect) { return rect && pos.x > rect.x && pos.x < rect.x + rect.width && pos.y > rect.y && pos.y < rect.y + rect.height; }
        function drawPauseScreen() { drawObjects(); drawPlayer(); drawUI(false); ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = 'white'; ctx.font = 'bold 48px Arial'; ctx.textAlign = 'center'; ctx.fillText('ì¼ì‹œì •ì§€', canvas.width / 2, canvas.height / 2); ctx.font = '24px Arial'; ctx.fillText('í™”ë©´ì„ ëˆŒëŸ¬ ë‹¤ì‹œ ì‹œì‘', canvas.width / 2, canvas.height / 2 + 50); }
        function drawUI(drawButton = true) { ctx.fillStyle = 'black'; ctx.font = '24px Arial'; ctx.textAlign = 'left'; ctx.fillText(`Score: ${score}`, 15, 30); const gaugeWidth = 150, gaugeHeight = 20, gaugeX = 15, gaugeY = 45; ctx.strokeStyle = '#333'; ctx.strokeRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight); const fillWidth = (gaugeWidth * feverScore) / FEVER_TRIGGER_COUNT; ctx.fillStyle = '#2ecc71'; ctx.fillRect(gaugeX, gaugeY, fillWidth, gaugeHeight); ctx.fillStyle = 'black'; ctx.font = '16px Arial'; ctx.fillText('FEVER', gaugeX + gaugeWidth + 10, gaugeY + 16); if (isFeverTime) { ctx.fillStyle = 'orange'; ctx.font = 'bold 36px Arial'; ctx.textAlign = 'center'; ctx.fillText(`FEVER TIME!`, canvas.width / 2, 50); ctx.fillText(`${(feverTimer / 1000).toFixed(1)}s`, canvas.width / 2, 90); } if (drawButton) { const btnSize = 40, margin = 15; const btnX = canvas.width - btnSize - margin; const btnY = margin; pauseButtonBox = { x: btnX, y: btnY, width: btnSize, height: btnSize }; ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(btnX, btnY, btnSize, btnSize); ctx.fillStyle = 'white'; ctx.fillRect(btnX + 10, btnY + 10, 7, 20); ctx.fillRect(btnX + 23, btnY + 10, 7, 20); } }
        async function gameLoop(timestamp) {
            if (gameState === 'loading') {
                ctx.fillStyle = 'black'; ctx.font = '24px Arial'; ctx.textAlign = 'center';
                ctx.fillText('ì´ë¯¸ì§€ ë¡œë”© ì¤‘...', canvas.width / 2, canvas.height / 2);
                requestAnimationFrame(gameLoop);
                return;
            }
            if (!lastTime) lastTime = timestamp; const deltaTime = timestamp - lastTime; lastTime = timestamp;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (gameState === 'startScreen') { await drawStartScreen(); }
            else if (gameState === 'playing') { updateObjects(deltaTime); movePlayer(); drawObjects(); drawPlayer(); drawUI(); }
            else if (gameState === 'paused') { drawPauseScreen(); }
            else if (gameState === 'gameOver') { drawGameOver(); }
            requestAnimationFrame(gameLoop);
        }
        function handleInteractionMove(e) { e.preventDefault(); if (gameState === 'playing' && (e.buttons === 1 || e.touches)) { player.dx = 0; const pos = getEventPos(e); targetX = pos.x - player.width / 2; } }
        document.addEventListener('keydown', handleKeyDown); document.addEventListener('keyup', handleKeyUp);
        canvas.addEventListener('touchstart', handleInteractionStart); canvas.addEventListener('touchmove', handleInteractionMove);
        canvas.addEventListener('mousedown', handleInteractionStart); canvas.addEventListener('mousemove', handleInteractionMove);
        function handleKeyDown(e) { if (gameState !== 'playing') return; if (e.key === 'ArrowRight' || e.key === 'Right') player.dx = player.speed; else if (e.key === 'ArrowLeft' || e.key === 'Left') player.dx = -player.speed; }
        function handleKeyUp(e) { if (e.key === 'ArrowRight' || e.key === 'Right' || e.key === 'ArrowLeft' || e.key === 'Left') player.dx = 0; }
        function drawGameOver() { ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = 'white'; ctx.font = 'bold 40px Arial'; ctx.textAlign = 'center'; ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 40); ctx.font = '24px Arial'; ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2); ctx.font = '20px Arial'; ctx.fillText('Tap to Save Score', canvas.width / 2, canvas.height / 2 + 40); }
        function movePlayer() { if (player.dx !== 0) { player.x += player.dx; targetX = player.x; } else { player.x += (targetX - player.x) * 0.5; } if (player.x < 0) player.x = 0; if (player.x + player.width > canvas.width) player.x = canvas.width - player.width; }
        function updateObjects(deltaTime) {
            spawnTimer += deltaTime; gameSpeedMultiplier = 1 + (score * 0.01);
            if (isFeverTime) {
                feverTimer -= deltaTime; if (feverTimer <= 0) isFeverTime = false;
                if (spawnTimer > FEVER_SPAWN_INTERVAL / gameSpeedMultiplier) { objects.push({ x: Math.random() * (canvas.width - 25), y: -25, width: 25, height: 25, speed: 200, type: 'good', color: 'red' }); spawnTimer = 0; }
            } else {
                if (spawnTimer > BASE_SPAWN_INTERVAL / gameSpeedMultiplier) {
                    let type = 'good', color = 'red'; const rand = Math.random();
                    if (rand < 0.3) { type = 'bad'; color = 'black'; }
                    else if (rand < 0.45) { type = 'special'; color = '#2ecc71'; }
                    objects.push({ x: Math.random() * (canvas.width - 25), y: -25, width: 25, height: 25, speed: (1.5 + Math.random() * 2) * 100, type: type, color: color });
                    spawnTimer = 0;
                }
            }
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i]; obj.y += obj.speed * gameSpeedMultiplier * (deltaTime / 1000);
                if (obj.y > canvas.height) { objects.splice(i, 1); continue; }
                if (player.x < obj.x + obj.width && player.x + player.width > obj.x &&
                    player.y < obj.y + obj.height && player.y + player.height > obj.y) {
                    if (obj.type === 'bad') { gameState = 'gameOver'; bgm.pause(); }
                    else if (obj.type === 'special') { feverScore++; objects.splice(i, 1); if (feverScore >= FEVER_TRIGGER_COUNT) { isFeverTime = true; feverTimer = FEVER_DURATION; feverScore = 0; } }
                    else { score++; objects.splice(i, 1); }
                }
            }
        }
        
        // --- ê²Œì„ ì‹œì‘ì  ---
        resizeCanvas();
        loadImages().then(() => {
            gameState = 'startScreen';
            gameLoop(0);
        }).catch(error => {
            console.error(error);
            alert('ìºë¦­í„° ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. íŒŒì¼ ê²½ë¡œë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.');
        });
    </script>
</body>
</html>
