<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>물체 피하기 게임 (오프라인 최종본)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { display: block; cursor: pointer; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <audio id="bgm" src="./Love3.mp3" loop></audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const bgm = document.getElementById('bgm');
        bgm.volume = 0.5;

        const characters = [
            { id: 1, name: '블루', color: '#3498db', speed: 9 },
            { id: 2, name: '그린', color: '#2ecc71', speed: 7 },
            { id: 3, name: '퍼플', color: '#8e44ad', speed: 8 }
        ];
        let selectedCharacterId = 1;
        
        let uiBoxes = {};
        let startScreenState = 'main'; 

        let player, objects, score, spawnTimer, targetX;
        let gameState = 'startScreen';
        let lastTime = 0;
        let gameSpeedMultiplier = 1;

        let feverScore = 0, isFeverTime = false, feverTimer = 0;
        const FEVER_DURATION = 5000;
        const FEVER_TRIGGER_COUNT = 10;
        const BASE_SPAWN_INTERVAL = 450;
        const FEVER_SPAWN_INTERVAL = 120;
        let pauseButtonBox = {};

        function init() {
            const selectedCharacter = characters.find(c => c.id === selectedCharacterId);
            player = { width: 60, height: 20, x: canvas.width / 2 - 30, y: canvas.height - 60, speed: selectedCharacter.speed, color: selectedCharacter.color, dx: 0 };
            targetX = player.x; objects = []; score = 0; spawnTimer = 0;
            gameSpeedMultiplier = 1; feverScore = 0; isFeverTime = false; feverTimer = 0;
            gameState = 'playing';
            bgm.currentTime = 0;
            bgm.play();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (gameState === 'startScreen') drawStartScreen();
            if (gameState === 'gameOver') drawGameOver();
            if (gameState === 'paused') drawPauseScreen();
        }
        window.addEventListener('resize', resizeCanvas);
        
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && gameState === 'playing') {
                gameState = 'paused';
                bgm.pause();
            }
        });

        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        function handleInteractionStart(e) {
            e.preventDefault();
            const pos = getEventPos(e);
            if (gameState === 'startScreen') {
                if (startScreenState === 'main') {
                    if (isInside(pos, uiBoxes.charSelectBtn)) startScreenState = 'characterSelect';
                    else if (isInside(pos, uiBoxes.leaderboardBtn)) {
                        // 순위 보기 버튼을 눌렀을 때의 동작 (지금은 비어있음)
                        startScreenState = 'leaderboard';
                    }
                    else if (isInside(pos, uiBoxes.startBtn)) init();
                } else {
                    if (startScreenState === 'characterSelect') {
                        uiBoxes.characterBoxes.forEach(box => { if (isInside(pos, box)) selectedCharacterId = box.id; });
                        if (isInside(pos, uiBoxes.confirmBtn)) startScreenState = 'main';
                    }
                    if (startScreenState === 'leaderboard' && isInside(pos, uiBoxes.backBtn)) {
                        startScreenState = 'main';
                    }
                }
            } else if (gameState === 'playing') {
                if (isInside(pos, pauseButtonBox)) { gameState = 'paused'; bgm.pause(); }
                else { player.dx = 0; targetX = pos.x - player.width / 2; }
            } else if (gameState === 'paused') {
                gameState = 'playing'; bgm.play();
            } else if (gameState === 'gameOver') {
                // 게임오버 시, 메인 메뉴로 돌아감
                gameState = 'startScreen';
                startScreenState = 'main';
            }
        }

        function drawStartScreen() {
            uiBoxes = {};
            ctx.fillStyle = '#ecf0f1';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (startScreenState === 'main') {
                drawMainMenu();
            } else if (startScreenState === 'leaderboard') {
                drawLeaderboardScreen();
            } else if (startScreenState === 'characterSelect') {
                drawCharacterSelectScreen();
            }
        }

        function drawMainMenu() {
            ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 48px Arial'; ctx.textAlign = 'center';
            ctx.fillText('물체 피하기 게임', canvas.width / 2, canvas.height * 0.2);
            const btnWidth = 250, btnHeight = 60, gap = 30;
            const btnX = (canvas.width - btnWidth) / 2, startY = canvas.height * 0.4;
            uiBoxes.charSelectBtn = { x: btnX, y: startY, width: btnWidth, height: btnHeight };
            ctx.fillStyle = '#2ecc71'; ctx.fillRect(btnX, startY, btnWidth, btnHeight);
            ctx.fillStyle = 'white'; ctx.font = 'bold 24px Arial'; ctx.fillText('캐릭터 선택', canvas.width / 2, startY + 38);
            uiBoxes.leaderboardBtn = { x: btnX, y: startY + btnHeight + gap, width: btnWidth, height: btnHeight };
            ctx.fillStyle = '#e67e22'; ctx.fillRect(btnX, startY + btnHeight + gap, btnWidth, btnHeight);
            ctx.fillStyle = 'white'; ctx.fillText('순위 보기', canvas.width / 2, startY + btnHeight + gap + 38);
            uiBoxes.startBtn = { x: btnX, y: startY + (btnHeight + gap) * 2, width: btnWidth, height: btnHeight };
            ctx.fillStyle = '#3498db'; ctx.fillRect(btnX, startY + (btnHeight + gap) * 2, btnWidth, btnHeight);
            ctx.fillStyle = 'white'; ctx.fillText('게임 시작', canvas.width / 2, startY + (btnHeight + gap) * 2 + 38);
        }

        function drawLeaderboardScreen() {
            ctx.fillStyle = '#34495e'; ctx.font = 'bold 32px Arial'; ctx.textAlign = 'center';
            ctx.fillText('🏆 순위표 🏆', canvas.width / 2, canvas.height * 0.2);
            ctx.font = '20px Arial';
            ctx.fillText('온라인 순위표 기능 추가 예정', canvas.width / 2, canvas.height * 0.4);
            drawBackButton(canvas.height * 0.85);
        }
        
        function drawCharacterSelectScreen() {
            ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 32px Arial'; ctx.textAlign = 'center';
            ctx.fillText('캐릭터를 선택하세요', canvas.width / 2, canvas.height * 0.2);
            const boxWidth = 100, boxHeight = 100, gap = 20;
            const totalWidth = (boxWidth * characters.length) + (gap * (characters.length - 1));
            let startX = (canvas.width - totalWidth) / 2;
            uiBoxes.characterBoxes = [];
            characters.forEach(char => {
                const boxY = canvas.height * 0.4;
                if (char.id === selectedCharacterId) { ctx.fillStyle = 'orange'; ctx.fillRect(startX - 5, boxY - 5, boxWidth + 10, boxHeight + 10); }
                ctx.fillStyle = char.color; ctx.fillRect(startX, boxY, boxWidth, boxHeight);
                ctx.fillStyle = '#2c3e50'; ctx.font = '20px Arial';
                ctx.fillText(char.name, startX + boxWidth / 2, boxY + boxHeight + 30);
                uiBoxes.characterBoxes.push({ id: char.id, x: startX, y: boxY, width: boxWidth, height: boxHeight });
                startX += boxWidth + gap;
            });
            const btnWidth = 150, btnHeight = 50;
            const btnX = (canvas.width - btnWidth) / 2;
            const btnY = canvas.height * 0.85;
            uiBoxes.confirmBtn = { x: btnX, y: btnY, width: btnWidth, height: btnHeight };
            ctx.fillStyle = '#2980b9'; ctx.fillRect(btnX, btnY, btnWidth, btnHeight);
            ctx.fillStyle = 'white'; ctx.font = 'bold 20px Arial';
            ctx.fillText('확인', canvas.width / 2, btnY + 32);
        }
        function drawBackButton(yPos) { const btnWidth = 150, btnHeight = 50; const btnX = (canvas.width - btnWidth) / 2; uiBoxes.backBtn = { x: btnX, y: yPos, width: btnWidth, height: btnHeight }; ctx.fillStyle = '#7f8c8d'; ctx.fillRect(btnX, yPos, btnWidth, btnHeight); ctx.fillStyle = 'white'; ctx.font = 'bold 20px Arial'; ctx.fillText('뒤로가기', canvas.width / 2, yPos + 32); }
        function isInside(pos, rect) { return rect && pos.x > rect.x && pos.x < rect.x + rect.width && pos.y > rect.y && pos.y < rect.y + rect.height; }
        function drawPauseScreen() { drawObjects(); drawPlayer(); drawUI(false); ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(0
