<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>YEAH! We Are CLOVERs!</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ€</text></svg>">
    <style>
        @font-face {
            font-family: 'MyGameFont';
            /* ì—ì…‹ ê²½ë¡œ í™•ì¸: ì‹¤ì œ í°íŠ¸ íŒŒì¼ì´ ./fonts/Pak_Yong_jun.ttf ì— ìˆëŠ”ì§€ í™•ì¸í•´ì•¼ í•©ë‹ˆë‹¤. */
            src: url('./fonts/Pak_Yong_jun.ttf') format('truetype');
        }
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
            cursor: pointer;
        }
        /* [ì¶”ê°€] ëª¨ë°”ì¼ í‚¤ë³´ë“œ í™œì„±í™”ë¥¼ ìœ„í•œ ìˆ¨ê²¨ì§„ ì…ë ¥ í•„ë“œ */
        #nicknameInputNative {
            position: absolute;
            opacity: 0; /* ì™„ì „íˆ íˆ¬ëª…í•˜ê²Œ ìˆ¨ê¹€ */
            pointer-events: none; /* ìº”ë²„ìŠ¤ ìƒí˜¸ì‘ìš©ì— ì˜í–¥ì„ ì£¼ì§€ ì•Šë„ë¡ í•¨ */
            width: 1px;
            height: 1px;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <audio id="bgm" src="./Love3.mp3" loop></audio>
    
    <!-- [ì¶”ê°€] ëª¨ë°”ì¼ í‚¤ë³´ë“œë¥¼ ê°•ì œë¡œ ë„ìš°ê¸° ìœ„í•œ ìˆ¨ê²¨ì§„ ë„¤ì´í‹°ë¸Œ Input -->
    <input type="text" id="nicknameInputNative" maxlength="10">

    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

    <script>
        // ==================================================================
        // ê²Œì„ ì„¤ì • (Constants & Config)
        // ==================================================================
        const GAME_WIDTH = 540;
        const GAME_HEIGHT = 960;
        const MAX_LIVES = 3;
        const BGM_VOLUME_NORMAL = 0.5;
        const BGM_VOLUME_MENU = BGM_VOLUME_NORMAL / 2; 
        const FEVER_DURATION = 5000;
        const FEVER_TRIGGER_COUNT = 10;
        const BASE_SPAWN_INTERVAL = 450;
        const FEVER_SPAWN_INTERVAL = 120;
        const OBJECT_POOL_SIZE = 100;
        const MAX_SFX_PER_FRAME = 3; 

        // [ìœ ì§€] ê²Œì„ ì˜¤ë²„ UI ì´ë™ëŸ‰: -200 ìœ ì§€
        const GAME_OVER_UI_SHIFT = -200; 

        const FIREBASE_CONFIG = {
            // TODO: ì‹¤ì œ í‚¤ ë¬¸ìì—´ë¡œ êµì²´í•´ì•¼ ìˆœìœ„í‘œ ê¸°ëŠ¥ì´ ì •ìƒ ì‘ë™í•©ë‹ˆë‹¤.
            apiKey: "ìƒˆë¡œ ë°œê¸‰ë°›ì€ í‚¤ ë¬¸ìì—´",
            authDomain: "clovergame-e712f.firebaseapp.com",
            projectId: "clovergame-e712f",
            storageBucket: "clovergame-e712f.appspot.com",
            messagingSenderId: "525191060039",
            appId: "1:525191060039:web:5707417e6e8ee8bf9cef62"
        };
        
        const characters = [
            { id: 1, name: 'PAIIEK', speed: 7, imgSrc: './char2.png', imgSrcSelected: './char2-1.png', imgIconSrc: './char2-2.png', imgHitSrc: './char2-3.png', selectSfxSrc: './sounds/char2-1.mp3', hitSfxSrc: './sounds/char2-1-1.mp3', selectVolume: 1.0, hitVolume: 1.0 },
            { id: 2, name: 'KANG', speed: 8, imgSrc: './char3.png', imgSrcSelected: './char3-1.png', imgIconSrc: './char3-2.png', imgHitSrc: './char3-3.png', selectSfxSrc: './sounds/char3-1.mp3', hitSfxSrc: './sounds/char3-1-1.mp3', selectVolume: 1.0, hitVolume: 1.0 },
            { id: 3, name: 'NAH', speed: 9, imgSrc: './char1.png', imgSrcSelected: './char1-1.png', imgIconSrc: './char1-2.png', imgHitSrc: './char1-3.png', selectSfxSrc: './sounds/char1-1.mp3', hitSfxSrc: './sounds/char1-1-1.mp3', selectVolume: 0.4, hitVolume: 1.0 }
        ];

        const IMAGE_ASSETS = {
            clover: './clover.png', love: './love.png', bomb: './bomb.png', title: './clover_title.png',
            darkGrayBtn: './darkgray.png', 
            lightGrayBtn: './lightgray.png', 
            major: './major.png',
            yellow: './yellow.png', silver: './silver.png', gray: './gray.png', circleBtn: './circle.png',
            soundOn: './sound_on.png', soundOff: './sound_off.png', ground: './ground.png'
        };
        const SOUND_ASSETS = {
            bombHit: './sounds/bomb_hit.mp3', buttonClick: './sounds/button_click.mp3',
            gameOver: './sounds/game_over.mp3', cloverTime: './sounds/clovertime.mp3',
            love1: './sounds/bbyong.mp3', love2: './sounds/heart.mp3', clover: './sounds/jump_low.mp3'
        };
        
        // --- ì „ì—­ ë³€ìˆ˜ (Global State) ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const bgm = document.getElementById('bgm');
        const nativeInput = document.getElementById('nicknameInputNative'); // ë„¤ì´í‹°ë¸Œ input ìš”ì†Œ
        
        let db, leaderboardCollection, cachedLeaderboard = null;
        let selectedCharacterId = 1;
        let uiBoxes = {}, startScreenState = 'main'; 
        let leaderboardScrollY = 0, isDragging = false, lastTouchY = 0;
        let player, objectPool, score, spawnTimer, targetX, playerHitbox = {};
        let gameState = 'loading', loadingError = null;
        let lastTime = 0, gameSpeedMultiplier = 1;
        let feverScore = 0, isFeverTime = false, feverTimer = 0;
        let lives;
        let animationFrameId;
        let hasInteracted = false; // ì˜¤ë””ì˜¤ í™œì„±í™” í”Œë˜ê·¸ (ìµœì´ˆ í„°ì¹˜ ì—¬ë¶€)
        let isMuted = false; // ìŒì†Œê±° ìƒíƒœ
        let finalRank = null; 
        
        const loadedImages = {};
        
        // Web Audio API ê´€ë ¨ ë³€ìˆ˜
        let audioContext = null; 
        let sfxBuffers = {}; // ë””ì½”ë”©ëœ ì˜¤ë””ì˜¤ ë²„í¼ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
        let sfxLastPlayed = {};
        let sfxPlayedThisFrame = 0;
        
        // [ì¶”ê°€] ë‹‰ë„¤ì„ ì…ë ¥ ê´€ë ¨ ìƒíƒœ ë° ì„ì‹œ ìˆœìœ„
        let currentNickname = '';
        const MAX_NICKNAME_LENGTH = 10;
        let isInputFocused = false;
        let preliminaryRank = null; // [ì¶”ê°€] ì ìˆ˜ ë“±ë¡ ì „ ì„ì‹œ ìˆœìœ„
        
        // [ìš”ì²­ 5] ê²Œì„ í”Œë ˆì´ ê²½í—˜ ìœ ë¬´
        let hasPlayedOnce = false; 
        
        // [ìš”ì²­ 4] ê¹œë¹¡ì„ íƒ€ì´ë¨¸
        let blinkTimer = 0;


        // ==================================================================
        // í•¨ìˆ˜ ì •ì˜ (Function Definitions)
        // ==================================================================

        // --- ì´ˆê¸°í™” ë° ë¦¬ì†ŒìŠ¤ ë¡œë”© ---
        function initializeFirebase() { 
            try { 
                const config = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : FIREBASE_CONFIG;
                firebase.initializeApp(config); 
                db = firebase.firestore(); 
                leaderboardCollection = db.collection('leaderboard'); 
            } catch (e) { 
                console.error("Firebase ì´ˆê¸°í™” ì˜¤ë¥˜:", e); 
                loadingError = e; 
                gameState = 'error'; 
            } 
        }
        
        function listenForLeaderboardUpdates() { if (!leaderboardCollection) return; leaderboardCollection.orderBy('score', 'desc').limit(30).onSnapshot(snapshot => { cachedLeaderboard = []; snapshot.forEach(doc => cachedLeaderboard.push(doc.data())); }, error => { console.error("ìˆœìœ„í‘œ ì‹¤ì‹œê°„ ë¡œë”© ì˜¤ë¥˜: ", error); cachedLeaderboard = []; }); }
        
        async function saveToLeaderboard(newScore, nickname) { if (!leaderboardCollection) return; try { const character = characters.find(c => c.id === selectedCharacterId); const characterName = character ? character.name : 'Unknown'; await leaderboardCollection.add({ score: newScore, name: nickname, character: characterName }); } catch (error) { console.error("ìˆœìœ„í‘œ ì €ì¥ ì˜¤ë¥˜:", error); } }

        async function loadAsset(type, name, src) {
            if (type === 'image') {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.src = src;
                    img.onload = () => {
                        loadedImages[name] = img; 
                        if (name.startsWith('char')) resolve(img);
                        else { resolve(); }
                    };
                    img.onerror = () => reject(`${type} ë¡œë“œ ì‹¤íŒ¨: ${src}`);
                });
            } else if (type === 'sound') {
                return fetch(src)
                    .then(response => {
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => {
                        return new Promise(async (resolve) => {
                            const tempContext = new (window.AudioContext || window.webkitAudioContext)();
                            tempContext.decodeAudioData(arrayBuffer.slice(0), 
                                buffer => {
                                    sfxBuffers[src] = buffer;
                                    tempContext.close();
                                    resolve();
                                }, 
                                error => {
                                    console.error(`Audio decode failed for ${src}:`, error);
                                    tempContext.close();
                                    resolve();
                                }
                            );
                        });
                    });
            }
            return Promise.resolve();
        }

        async function loadGameAssets() {
            const imagePromises = Object.entries(IMAGE_ASSETS).map(([name, src]) => loadAsset('image', name, src));
            const charImagePromises = characters.flatMap(char => [
                loadAsset('image', 'char_img', char.imgSrc).then(img => { char.img = img; char.originalWidth = img.naturalWidth; char.originalHeight = img.naturalHeight; }),
                loadAsset('image', 'char_selected', char.imgSrcSelected).then(img => char.imgSelected = img),
                loadAsset('image', 'char_icon', char.imgIconSrc).then(img => char.imgIcon = img),
                char.imgHitSrc ? loadAsset('image', 'char_hit', char.imgHitSrc).then(img => char.imgHit = img) : Promise.resolve()
            ]);
            const soundSrcs = [...new Set([...Object.values(SOUND_ASSETS), ...characters.flatMap(c => [c.selectSfxSrc, c.hitSfxSrc])].filter(Boolean))];
            const soundPromises = soundSrcs.map(src => loadAsset('sound', null, src));
            
            await Promise.all([...imagePromises, ...charImagePromises, ...soundPromises, document.fonts.ready]);
        }
        
        function playSound(src, volume = 1.0) {
            if (isMuted || !hasInteracted || !sfxBuffers[src] || !audioContext) return; 

            const now = performance.now();
            const cooldown = 75;
            if (src === SOUND_ASSETS.clover) {
                if (sfxLastPlayed[src] && now - sfxLastPlayed[src] < cooldown) { return; }
                sfxLastPlayed[src] = now;
            }

            if (sfxPlayedThisFrame >= MAX_SFX_PER_FRAME) {
                return;
            }
            sfxPlayedThisFrame++;

            try {
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();

                source.buffer = sfxBuffers[src];
                gainNode.gain.value = volume;

                source.connect(gainNode);
                gainNode.connect(audioContext.destination);

                source.start(0);
                
                source.onended = () => {
                    source.disconnect();
                    gainNode.disconnect();
                };

            } catch (e) {
                console.error("Web Audio API playback failed:", e);
            }
        }

        // [ì¶”ê°€] ë“±ë¡ ì „ ì„ì‹œ ìˆœìœ„ë¥¼ ê³„ì‚°í•˜ê³  í‘œì‹œí•©ë‹ˆë‹¤.
        async function getPreliminaryRank(currentScore) {
            if (!leaderboardCollection || currentScore === undefined) return;
            
            preliminaryRank = 'calculating';
            drawCurrentState();

            try {
                // í˜„ì¬ ì ìˆ˜ë³´ë‹¤ ë†’ì€ ì ìˆ˜ë¥¼ ê°€ì§„ ë¬¸ì„œì˜ ê°œìˆ˜ë¥¼ ì„¸ê¸° ìœ„í•œ ì¿¼ë¦¬
                const higherScoresSnapshot = await leaderboardCollection
                    .where('score', '>', currentScore)
                    .get();
                
                preliminaryRank = higherScoresSnapshot.size + 1;
            } catch (error) {
                console.error("Preliminary rank calculation error:", error);
                preliminaryRank = '??';
            } finally {
                 drawCurrentState();
            }
        }

        // --- ê²Œì„ ë¡œì§ ---
        function init() {
            const char = characters.find(c => c.id === selectedCharacterId);
            const playerWidth = GAME_WIDTH * 0.2;
            const aspectRatio = char.originalHeight / char.originalWidth;
            const playerHeight = playerWidth * aspectRatio;
            player = { width: playerWidth, height: playerHeight, x: GAME_WIDTH / 2 - playerWidth / 2, y: GAME_HEIGHT - playerHeight - (GAME_HEIGHT * 0.1), speed: char.speed, img: char.img, originalImg: char.img, imgHit: char.imgHit, hitTimer: 0, dx: 0 };
            targetX = player.x; score = 0; spawnTimer = 0;
            gameSpeedMultiplier = 1; feverScore = 0; isFeverTime = false; feverTimer = 0;
            lives = MAX_LIVES; gameState = 'playing';
            finalRank = null;
            preliminaryRank = null; // ê²Œì„ ì‹œì‘ ì‹œ ì´ˆê¸°í™”
            currentNickname = '';
            isInputFocused = false;
            nativeInput.value = ''; // ë„¤ì´í‹°ë¸Œ input ì´ˆê¸°í™”
            nativeInput.blur(); // ë„¤ì´í‹°ë¸Œ input í¬ì»¤ìŠ¤ í•´ì œ
            objectPool = [];
            for (let i = 0; i < OBJECT_POOL_SIZE; i++) objectPool.push({ active: false });
            bgm.currentTime = 0;
            bgm.volume = BGM_VOLUME_NORMAL; // ì¸ê²Œì„ ë³¼ë¥¨ ì„¤ì •
            
            // [ìˆ˜ì •] ê²Œì„ ì‹œì‘ ì‹œ ë¬´ì¡°ê±´ BGM ì¬ìƒ ì‹œë„ (AudioContext resume í¬í•¨)
            if (!isMuted) { 
                initAudioContext(true); // ê°•ì œ ì¬ìƒ ì‹œë„ (ì¸ê²Œì„ ë³¼ë¥¨)
            }
        }

        function spawnObject() {
            const inactiveObj = objectPool.find(obj => !obj.active);
            if (inactiveObj) {
                inactiveObj.active = true;
                inactiveObj.x = Math.random() * (GAME_WIDTH - 40);
                inactiveObj.y = -40;
                inactiveObj.width = 40;
                inactiveObj.height = 40;
                if (isFeverTime) {
                    inactiveObj.speed = 200;
                    inactiveObj.type = 'good';
                } else {
                    const bombChance = Math.min(0.7, 0.3 + (score / 500) * 0.2);
                    const specialChance = 0.15;
                    const rand = Math.random();
                    if (rand < bombChance) inactiveObj.type = 'bad';
                    else if (rand < bombChance + specialChance) inactiveObj.type = 'special';
                    else inactiveObj.type = 'good';
                    inactiveObj.speed = (1.5 + Math.random() * 2) * 100;
                }
            }
        }

        function movePlayer() {
            if(player.dx !== 0) { player.x += player.dx; targetX = player.x; }
            else { player.x += (targetX - player.x) * 0.5; }
            player.x = Math.max(0, Math.min(player.x, GAME_WIDTH - player.width));
        }
        
        function updateObjects(deltaTime) {
            spawnTimer += deltaTime; 
            gameSpeedMultiplier = Math.min(4, 1 + (score * 0.01));
            playerHitbox.x = player.x + player.width * 0.2;
            playerHitbox.y = player.y;
            playerHitbox.width = player.width * 0.6;
            playerHitbox.height = player.height * 0.5;
            if (player.hitTimer > 0) player.hitTimer -= deltaTime;
            if (isFeverTime) {
                feverTimer -= deltaTime;
                if (feverTimer <= 0) isFeverTime = false;
            }
            const spawnInterval = isFeverTime ? FEVER_SPAWN_INTERVAL : BASE_SPAWN_INTERVAL;
            if (spawnTimer > spawnInterval / gameSpeedMultiplier) {
                spawnTimer = 0;
                spawnObject();
            }
            objectPool.forEach(obj => {
                if (!obj.active) return;
                obj.y += obj.speed * gameSpeedMultiplier * (deltaTime / 1000);
                if (obj.y > GAME_HEIGHT) obj.active = false;
                if (playerHitbox.x < obj.x + obj.width && playerHitbox.x + playerHitbox.width > obj.x && playerHitbox.y < obj.y + obj.height && playerHitbox.y + playerHitbox.height > obj.y) {
                    handleCollision(obj);
                    obj.active = false;
                }
            });
        }

        function handleCollision(obj) {
            if (obj.type === 'bad') {
                lives--;
                player.hitTimer = 500;
                const char = characters.find(c => c.id === selectedCharacterId);
                if (char) playSound(char.hitSfxSrc, char.hitVolume);
                playSound(SOUND_ASSETS.bombHit, 1.0);
                if (lives <= 0) { 
                    gameState = 'gameOver'; 
                    bgm.pause(); 
                    playSound(SOUND_ASSETS.gameOver);
                    getPreliminaryRank(score); // [ì¶”ê°€] ê²Œì„ ì˜¤ë²„ ì‹œ ì¦‰ì‹œ ìˆœìœ„ ê³„ì‚° ì‹œì‘
                }
            } else if (obj.type === 'special') {
                feverScore++;
                playSound(Math.random() < 0.5 ? SOUND_ASSETS.love1 : SOUND_ASSETS.love2);
                if (feverScore >= FEVER_TRIGGER_COUNT) { 
                    isFeverTime = true; 
                    feverTimer = FEVER_DURATION; 
                    feverScore = 0; 
                    playSound(SOUND_ASSETS.cloverTime); 
                }
            } else { 
                score++; 
                playSound(SOUND_ASSETS.clover); 
            }
        }
        
        // --- ë Œë”ë§ ---
        function drawPlayer() { 
            let imgToDraw = player.originalImg;
            
            if (player.hitTimer > 0) {
                const flashRate = 100; // 100ms
                const isVisible = Math.floor(player.hitTimer / flashRate) % 2 === 0;
                
                if (isVisible) {
                    imgToDraw = player.imgHit || player.originalImg;
                } else {
                    imgToDraw = null;
                }
            }
            
            if (imgToDraw) {
                ctx.drawImage(imgToDraw, player.x, player.y, player.width, player.height);
            }
        }

        function drawObjects() { objectPool.forEach(obj => { if (!obj.active) return; let imgToDraw; if (obj.type === 'good') imgToDraw = loadedImages.clover; else if (obj.type === 'special') imgToDraw = loadedImages.love; else if (obj.type === 'bad') imgToDraw = loadedImages.bomb; if (imgToDraw) ctx.drawImage(imgToDraw, obj.x, obj.y, obj.width, obj.height); }); }
        
        function drawButton(yPos, text, img, textColor, id, width = 150, height = 50, xOffset = 0) { 
            const btnWidth = width, btnHeight = height;
            const btnX = (GAME_WIDTH - btnWidth) / 2 + xOffset; 
            uiBoxes[id] = { x: btnX, y: yPos, width: btnWidth, height: btnHeight }; 
            if(img) ctx.drawImage(img, btnX, yPos, btnWidth, btnHeight); 
            ctx.fillStyle = textColor; ctx.font = 'bold 20px "MyGameFont"'; ctx.textAlign = 'center'; 
            ctx.fillText(text, btnX + btnWidth / 2, yPos + (height * 0.64));
        }

        function drawGround() { const ground = loadedImages.ground; if (ground) { const imgHeight = (ground.naturalHeight / ground.naturalWidth) * GAME_WIDTH; const visiblePortion = 0.85; ctx.drawImage(ground, 0, GAME_HEIGHT - (imgHeight * visiblePortion), GAME_WIDTH, imgHeight); } }
        
        function drawMuteButton() { 
            const muteBtnSize = 60, muteBtnMargin = 20, muteBtnX = muteBtnMargin, muteBtnY = GAME_HEIGHT - muteBtnSize - muteBtnMargin; 
            uiBoxes.muteBtn = { x: muteBtnX, y: muteBtnY, width: muteBtnSize, height: muteBtnSize }; 
            let imgToDraw = isMuted ? loadedImages.soundOff : loadedImages.soundOn; 
            if (imgToDraw) ctx.drawImage(imgToDraw, muteBtnX, muteBtnY, muteBtnSize, muteBtnSize); 
        }

        function drawCreditScreen() {
            ctx.fillStyle = '#2c3e50';
            ctx.textAlign = 'center';
            let currentY = GAME_HEIGHT * 0.15;
            const titleFontSize = 24;
            const contentFontSize = 18;
            const lineHeight = 30;
            const sectionGap = 35;
            const credits = [
                { title: 'Made by', text: ['X_@chakoll23'] },
                { title: 'Sound', text: ['SFX : ì…€ë°”ì´ë®¤ì§ (Sellbuymusic)', 'BGM : "Love Love Love (Chiptune ver.)" - ë‚˜ìƒí˜„ì”¨ë°´ë“œ'] },
                { title: 'Voice', text: ['ë°±ìŠ¹ë ¬, ê°•í˜„ì›…, ë‚˜ìƒí˜„'] },
                { title: 'Font', text: ['Main : ë°•ìš©ì¤€íˆ¬ì‚¬íšŒë³´ì²´', 'Logo : í‰ì°½ì²´, í‰ì°½ í‰í™”ì²´'] },
                { title: 'For', text: ['ë‚˜ì”¨ë°´, ë‚˜ì”¨íŒ¬'] }
            ];
            credits.forEach(credit => {
                ctx.font = `bold ${titleFontSize}px "MyGameFont"`;
                ctx.fillText(credit.title, GAME_WIDTH / 2, currentY);
                currentY += lineHeight;
                ctx.font = `${contentFontSize}px "MyGameFont"`;
                credit.text.forEach(line => {
                    ctx.fillText(line, GAME_WIDTH / 2, currentY);
                    currentY += lineHeight;
                });
                currentY += (sectionGap - lineHeight);
            });
            drawButton(GAME_HEIGHT * 0.9, 'í™•ì¸', loadedImages.darkGrayBtn, 'white', 'confirmBtn');
        }

        function drawLeaderboardScreen() {
            let listStartY = GAME_HEIGHT * 0.15; 
            const majorImg = loadedImages.major;
            if (majorImg) {
                const imgWidth = GAME_WIDTH * 0.6;
                const imgHeight = (majorImg.naturalHeight / majorImg.naturalWidth) * imgWidth;
                const imgY = GAME_HEIGHT * 0.05;
                ctx.drawImage(majorImg, (GAME_WIDTH - imgWidth) / 2, imgY, imgWidth, imgHeight);
                const textY = imgY + imgHeight + 25;
                ctx.fillStyle = '#888888'; ctx.font = '12px "MyGameFont"'; ctx.textAlign = 'center';
                ctx.fillText('*íƒ€ì¸ì—ê²Œ ìƒì²˜ë¥¼ ì£¼ëŠ” ë‹‰ë„¤ì„ì€ ì˜ˆê³  ì—†ì´ ì‚­ì œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.', GAME_WIDTH / 2, textY);
                listStartY = textY + 20;
            }
            const listHeight = GAME_HEIGHT - listStartY - 100;
            const boxWidth = Math.min(GAME_WIDTH * 0.8, 350); const boxHeight = 40, gap = 10;
            if (cachedLeaderboard === null) { ctx.font = '20px "MyGameFont"'; ctx.fillText('ë¡œë”© ì¤‘...', GAME_WIDTH / 2, listStartY + 50); }
            else if (cachedLeaderboard.length === 0) { ctx.font = '20px "MyGameFont"'; ctx.fillText('ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤!', GAME_WIDTH / 2, listStartY + 50); }
            else { 
                const leaderboardItemsHeight = cachedLeaderboard.length * (boxHeight + gap) - gap;
                const scrollableAreaHeight = listHeight;
                const maxScroll = 0; 
                const minScroll = -Math.max(0, leaderboardItemsHeight - scrollableAreaHeight);
                leaderboardScrollY = Math.max(minScroll, Math.min(maxScroll, leaderboardScrollY));
                ctx.save(); 
                ctx.beginPath(); 
                ctx.rect(0, listStartY, GAME_WIDTH, scrollableAreaHeight);
                ctx.clip();
                cachedLeaderboard.forEach((entry, index) => {
                    const rank = index + 1;
                    const boxY = listStartY + index * (boxHeight + gap) + leaderboardScrollY;
                    let boxImg;
                    
                    if (rank <= 3) {
                        boxImg = loadedImages.yellow; // 1~3ìœ„: Yellow
                    } else if (rank <= 10) { 
                        boxImg = loadedImages.silver; // 4~10ìœ„: Silver
                    } else {
                        boxImg = loadedImages.gray; // 11ìœ„~: Gray
                    }
                    
                    if (boxImg) ctx.drawImage(boxImg, (GAME_WIDTH - boxWidth) / 2, boxY, boxWidth, boxHeight);
                    ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 18px "MyGameFont"'; const rankTextX = (GAME_WIDTH - boxWidth) / 2 + 20;
                    const character = characters.find(c => c.name === entry.character);
                    if (character && character.imgIcon) {
                        const iconSize = 24; const iconX = rankTextX + 35;
                        ctx.drawImage(character.imgIcon, iconX, boxY + (boxHeight - iconSize) / 2, iconSize, iconSize);
                        ctx.textAlign = 'left';
                        ctx.fillText(entry.name, iconX + iconSize + 10, boxY + 25);
                    } else { ctx.textAlign = 'left'; ctx.fillText(entry.name, rankTextX + 35, boxY + 25); }
                    ctx.fillText(`${rank}.`, rankTextX, boxY + 25);
                    ctx.textAlign = 'right';
                    ctx.fillText(entry.score, (GAME_WIDTH + boxWidth) / 2 - 20, boxY + 25);
                });
                ctx.restore();
            }
            drawButton(GAME_HEIGHT * 0.9, 'í™•ì¸', loadedImages.darkGrayBtn, 'white', 'confirmBtn');
        }

        function drawCharacterSelectScreen() {
            ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 32px "MyGameFont"'; ctx.textAlign = 'center'; ctx.fillText('ìºë¦­í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”', GAME_WIDTH / 2, GAME_HEIGHT * 0.15);
            const displayCharSize = Math.min(GAME_WIDTH / 3.5, 120); const gap = 20;
            const totalWidth = (displayCharSize * characters.length) + (gap * (characters.length - 1));
            let startX = (GAME_WIDTH - totalWidth) / 2;
            const boxY = (GAME_HEIGHT - displayCharSize) / 2 - 50;
            uiBoxes.characterBoxes = [];
            characters.forEach(char => {
                const isSelected = char.id === selectedCharacterId;
                const scale = isSelected ? 1.2 : 1.0;
                const currentSize = displayCharSize * scale;
                const currentX = startX - (currentSize - displayCharSize) / 2;
                const currentY = boxY - (currentSize - displayCharSize) / 2;
                let imgToDraw = isSelected ? char.imgSelected : char.img;
                if (imgToDraw) {
                    const aspectRatio = char.originalHeight / char.originalWidth;
                    let imgDrawWidth = currentSize;
                    let imgDrawHeight = currentSize * aspectRatio;
                    const imgDrawX = currentX + (currentSize - imgDrawWidth) / 2;
                    const imgDrawY = currentY + (currentSize - imgDrawHeight) / 2;
                    ctx.drawImage(imgToDraw, imgDrawX, imgDrawY, imgDrawWidth, imgDrawHeight);
                }
                ctx.fillStyle = '#2c3e50'; ctx.font = '20px "MyGameFont"'; ctx.fillText(char.name, startX + displayCharSize / 2, boxY + displayCharSize + 30);
                uiBoxes.characterBoxes.push({ id: char.id, x: startX, y: boxY, width: displayCharSize, height: displayCharSize });
                startX += displayCharSize + gap;
            });
            drawButton(GAME_HEIGHT * 0.8, 'í™•ì¸', loadedImages.darkGrayBtn, 'white', 'confirmBtn');
        }
        
        function drawMainMenu() {
            uiBoxes = {}; // uiBoxes ì´ˆê¸°í™”
            ctx.fillStyle = '#f0f0f0'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            let currentY = GAME_HEIGHT * 0.1;
            const titleImg = loadedImages.title;
            if (titleImg) {
                const imgWidth = GAME_WIDTH * 0.7;
                const imgHeight = (titleImg.naturalHeight / titleImg.naturalWidth) * imgWidth;
                ctx.drawImage(titleImg, (GAME_WIDTH - imgWidth) / 2, currentY, imgWidth, imgHeight);
                currentY += imgHeight + 20;
            }
            ctx.fillStyle = '#2c3e50'; ctx.font = '18px "MyGameFont"'; ctx.textAlign = 'center';
            const lineHeight = 28; const iconSize = 20;
            currentY += 20;
            ctx.fillText('<ê²Œì„ë°©ë²•>', GAME_WIDTH / 2, currentY);
            currentY += lineHeight * 1.5;
            function drawLineWithIconAndColor(text, icon, y, textColor = '#2c3e50') { const textWidth = ctx.measureText(text).width; const totalWidth = iconSize + 5 + textWidth; const startX = (GAME_WIDTH - totalWidth) / 2; if (icon) { ctx.drawImage(icon, startX, y - iconSize, iconSize, iconSize); } ctx.textAlign = 'left'; ctx.fillStyle = textColor; ctx.fillText(text, startX + iconSize + 5, y); }
            drawLineWithIconAndColor('ë¥¼ ë§ì´ ë°›ì•„ ì ìˆ˜ë¥¼ ë‚´ëŠ” ê²Œì„ì…ë‹ˆë‹¤!', loadedImages.clover, currentY); currentY += lineHeight;
            const line2_part1 = 'ë¥¼ 10ë²ˆ ë°›ì•„ '; const line2_part2 = 'LOVE'; const line2_part3 = ' ê²Œì´ì§€ê°€ ê°€ë“ ì°¨ë©´';
            const line2_part1Width = ctx.measureText(line2_part1).width; const line2_part2Width = ctx.measureText(line2_part2).width;
            const line2TotalWidth = iconSize + 5 + line2_part1Width + line2_part2Width + ctx.measureText(line2_part3).width;
            const line2StartX = (GAME_WIDTH - line2TotalWidth) / 2;
            if (loadedImages.love) ctx.drawImage(loadedImages.love, line2StartX, currentY - iconSize, iconSize, iconSize);
            ctx.textAlign = 'left'; ctx.fillStyle = '#2c3e50'; ctx.fillText(line2_part1, line2StartX + iconSize + 5, currentY);
            ctx.fillStyle = '#ff69b4'; ctx.fillText(line2_part2, line2StartX + iconSize + 5 + line2_part1Width, currentY);
            ctx.fillStyle = '#2c3e50'; ctx.fillText(line2_part3, line2StartX + iconSize + 5 + line2_part1Width + line2_part2Width, currentY); currentY += lineHeight;
            const text1 = "CLOVER TIME"; const text2 = "ì´ ë°œë™í•©ë‹ˆë‹¤";
            const text1Width = ctx.measureText(text1).width; const totalTextWidth = text1Width + ctx.measureText(text2).width;
            let textStartX = (GAME_WIDTH - totalTextWidth) / 2;
            ctx.textAlign = 'left'; ctx.fillStyle = '#27ae60'; ctx.fillText(text1, textStartX, currentY);
            ctx.fillStyle = '#2c3e50'; ctx.fillText(text2, textStartX + text1Width, currentY); currentY += lineHeight;
            const line4_part1 = 'ë¥¼ ì„¸ ë²ˆ ë§ìœ¼ë©´ '; const line4_part2 = 'GAME OVER!';
            const line4_part1Width = ctx.measureText(line4_part1).width; const line4TotalWidth = iconSize + 5 + line4_part1Width + ctx.measureText(line4_part2).width;
            const line4StartX = (GAME_WIDTH - line4TotalWidth) / 2;
            if (loadedImages.bomb) ctx.drawImage(loadedImages.bomb, line4StartX, currentY - iconSize, iconSize, iconSize);
            ctx.textAlign = 'left'; ctx.fillStyle = '#2c3e50'; ctx.fillText(line4_part1, line4StartX + iconSize + 5, currentY);
            ctx.fillStyle = 'red'; ctx.fillText(line4_part2, line4StartX + iconSize + 5 + line4_part1Width, currentY); currentY += lineHeight;
            const line5_part1 = "ì ìˆ˜ê°€ TOP 30 ì•ˆì— ë“ ë‹¤ë©´ "; 
            const line5_part2 = "ëª…ì˜ˆì˜ ì „ë‹¹"; const line5_part3 = "ì— ì´ë¦„ì„ ì˜¬ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤";
            const line5_part1Width = ctx.measureText(line5_part1).width; const line5_part2Width = ctx.measureText(line5_part2).width;
            const line5TotalWidth = line5_part1Width + line5_part2Width + ctx.measureText(line5_part3).width;
            const line5StartX = (GAME_WIDTH - line5TotalWidth) / 2;
            ctx.textAlign = 'left'; ctx.fillStyle = '#2c3e50'; ctx.fillText(line5_part1, line5StartX, currentY);
            ctx.fillStyle = '#e67e22'; ctx.fillText(line5_part2, line5StartX + line5_part1Width, currentY);
            ctx.fillStyle = '#2c3e50'; ctx.fillText(line5_part3, line5StartX + line5_part1Width + line5_part2Width, currentY); currentY += lineHeight;
            ctx.textAlign = 'center'; ctx.fillText('ì¬ë¯¸ìˆê²Œ ì¦ê²¨ì£¼ì„¸ìš”!â¤ï¸', GAME_WIDTH / 2, currentY); currentY += 40;
            const btnWidth = Math.min(GAME_WIDTH * 0.7, 300), btnHeight = Math.min(GAME_HEIGHT * 0.08, 60);
            const gap = btnHeight * 0.5, btnX = (GAME_WIDTH - btnWidth) / 2;
            const btnFontSize = Math.min(btnHeight * 0.4, 24);
            ctx.font = `bold ${btnFontSize}px "MyGameFont"`;
            let buttonStartY = currentY;
            
            const mainMenuButtons = [ 
                { id: 'charSelectBtn', text: 'ìºë¦­í„° ì„ íƒ', y: buttonStartY, img: loadedImages.darkGrayBtn, color: 'white' }, 
                { id: 'leaderboardBtn', text: 'ëª…ì˜ˆì˜ ì „ë‹¹', y: buttonStartY + btnHeight + gap, img: loadedImages.lightGrayBtn, color: 'black' }, 
                { id: 'startBtn', text: 'ê²Œì„ ì‹œì‘', y: buttonStartY + (btnHeight + gap) * 2, img: loadedImages.darkGrayBtn, color: 'white' } 
            ];
            
            mainMenuButtons.forEach(btn => { 
                uiBoxes[btn.id] = { x: btnX, y: btn.y, width: btnWidth, height: btnHeight }; 
                if(btn.img) ctx.drawImage(btn.img, btnX, btn.y, btnWidth, btnHeight); 
                ctx.fillStyle = btn.color; ctx.textAlign = 'center'; 
                ctx.fillText(btn.text, GAME_WIDTH / 2, btn.y + btnHeight / 2 + (btnFontSize / 3)); 
            });

            // [ìˆ˜ì •] ë°°ê²½ìŒ ì¬ìƒ ì•ˆë‚´ ë¬¸êµ¬ ìœ„ì¹˜ ì¡°ì • (+30 -> +45)
            if (!hasPlayedOnce) {
                // blinkTimerë¥¼ ì‚¬ìš©í•˜ì—¬ 0.2 ~ 1.0 ì‚¬ì´ì˜ ë¶ˆíˆ¬ëª…ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
                const blinkPhase = Math.abs(Math.sin(blinkTimer * Math.PI)); 
                ctx.fillStyle = `rgba(40, 167, 69, ${blinkPhase * 0.8 + 0.2})`; // ì—°ë‘ìƒ‰ (Greenish color)
                ctx.font = '18px "MyGameFont"';
                ctx.textAlign = 'center';
                
                // ìœ„ì¹˜ ì¡°ì •: Yì¢Œí‘œë¥¼ 15 ë” ë‚´ë¦¼ (30 -> 45)
                const blinkTextY = buttonStartY + (btnHeight * 3) + (gap * 2) + 45;
                ctx.fillText('â˜˜ï¸í™”ë©´ì˜ ì•„ë¬´ ê³³ì´ë‚˜ í„°ì¹˜í•˜ë©´ ë°°ê²½ìŒì´ ì¬ìƒë©ë‹ˆë‹¤â˜˜ï¸', GAME_WIDTH / 2, blinkTextY);
            }

            const creditBtnSize = 60, creditBtnMargin = 20;
            const creditBtnX = GAME_WIDTH - creditBtnSize - creditBtnMargin, creditBtnY = GAME_HEIGHT - creditBtnSize - creditBtnMargin;
            uiBoxes.creditBtn = { x: creditBtnX, y: creditBtnY, width: creditBtnSize, height: creditBtnSize };
            if (loadedImages.circleBtn) ctx.drawImage(loadedImages.circleBtn, creditBtnX, creditBtnY, creditBtnSize, creditBtnSize);
            ctx.fillStyle = 'black'; ctx.font = `bold ${creditBtnSize * 0.25}px "MyGameFont"`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('Credit', creditBtnX + creditBtnSize / 2, creditBtnY + creditBtnSize / 2);
            ctx.textBaseline = 'alphabetic';
        }

        function drawPauseScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            const btnWidth = 200, btnHeight = 60, gap = 30;
            const centerX = GAME_WIDTH / 2, centerY = GAME_HEIGHT / 2;
            uiBoxes.resumeBtn = { x: centerX - btnWidth / 2, y: centerY - btnHeight - gap / 2, width: btnWidth, height: btnHeight };
            if(loadedImages.lightGrayBtn) ctx.drawImage(loadedImages.lightGrayBtn, uiBoxes.resumeBtn.x, uiBoxes.resumeBtn.y, uiBoxes.resumeBtn.width, uiBoxes.resumeBtn.height);
            ctx.fillStyle = 'black'; ctx.font = 'bold 24px "MyGameFont"'; ctx.textAlign = 'center';
            ctx.fillText('ê³„ì†í•˜ê¸°', centerX, centerY - btnHeight / 2 - gap / 2 + 8);
            uiBoxes.toMainBtn = { x: centerX - btnWidth / 2, y: centerY + gap / 2, width: btnWidth, height: btnHeight };
            if(loadedImages.darkGrayBtn) ctx.drawImage(loadedImages.darkGrayBtn, uiBoxes.toMainBtn.x, uiBoxes.toMainBtn.y, uiBoxes.toMainBtn.width, uiBoxes.toMainBtn.height);
            ctx.fillStyle = 'white'; ctx.fillText('ë©”ì¸ìœ¼ë¡œ', centerX, centerY + btnHeight / 2 + gap / 2 + 8);
        }

        // [ìˆ˜ì •] ë‹‰ë„¤ì„ ì…ë ¥ ë° ìˆœìœ„ í‘œì‹œë¥¼ ìœ„í•œ UI ë¡œì§ ë³€ê²½ ë° PC/ëª¨ë°”ì¼ ë¶„ë¦¬ ì ìš©
        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT); 
            
            // [ìˆ˜ì •] PC/ëª¨ë°”ì¼ ë¶„ë¦¬: isInputFocused ìƒíƒœì´ê³  ë·°í¬íŠ¸ ë„ˆë¹„ê°€ 768px ë¯¸ë§Œì¼ ë•Œë§Œ UIë¥¼ ì´ë™ì‹œí‚µë‹ˆë‹¤.
            let UI_SHIFT = 0;
            if (isInputFocused && window.innerWidth < 768) {
                UI_SHIFT = GAME_OVER_UI_SHIFT; // -200
            }
            
            const CENTER_Y = GAME_HEIGHT / 2 + UI_SHIFT;
            
            ctx.fillStyle = 'white'; ctx.font = 'bold 40px "MyGameFont"'; ctx.textAlign = 'center'; 
            ctx.fillText('GAME OVER', GAME_WIDTH / 2, CENTER_Y - 160); 
            
            // 1. ìµœì¢… ì ìˆ˜ í‘œì‹œ
            ctx.font = '24px "MyGameFont"'; 
            ctx.fillText('Final Score: ' + score, GAME_WIDTH / 2, CENTER_Y - 100); 

            // 2. ìˆœìœ„ í‘œì‹œ/ê³„ì‚° ìƒíƒœ
            ctx.font = 'bold 28px "MyGameFont"';
            let rankText = '';
            if (preliminaryRank === 'calculating') {
                rankText = 'ìˆœìœ„ ê³„ì‚° ì¤‘...';
                ctx.font = '20px "MyGameFont"';
            } else if (finalRank !== null && finalRank !== 'saving') {
                // ì €ì¥ í›„ ìµœì¢… ìˆœìœ„
                rankText = `ë‹¹ì‹ ì˜ ìˆœìœ„: ${finalRank}ìœ„`;
            } else {
                // ì €ì¥ ì „ ì„ì‹œ ìˆœìœ„
                rankText = `ì˜ˆìƒ ìˆœìœ„: ${preliminaryRank || '??'}ìœ„`;
            }
            ctx.fillText(rankText, GAME_WIDTH / 2, CENTER_Y - 40);

            if (finalRank === null || finalRank === 'saving') {
                // 3. ë‹‰ë„¤ì„ ì…ë ¥ ë° ë²„íŠ¼ (ìˆœìœ„ ê³„ì‚° ì¤‘ì´ë”ë¼ë„ ì…ë ¥ ê°€ëŠ¥)
                
                ctx.font = '20px "MyGameFont"'; 
                ctx.fillText('ìˆœìœ„ì— ë“±ë¡í•  ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”.', GAME_WIDTH / 2, CENTER_Y + 20);

                // 4. ë‹‰ë„¤ì„ ì…ë ¥ í•„ë“œ (ìº”ë²„ìŠ¤ ë Œë”ë§)
                const inputWidth = 250, inputHeight = 40;
                const inputX = (GAME_WIDTH - inputWidth) / 2;
                const inputY = CENTER_Y + 70; // UIë¥¼ ì•„ë˜ë¡œ ë‚´ë¦¼
                const btnGap = 10, btnWidth = 120, btnHeight = 50;
                const btnY = inputY + inputHeight + 40;
                
                // ì…ë ¥ í•„ë“œ ë°°ê²½
                ctx.fillStyle = isInputFocused ? '#fffbe6' : '#fff';
                ctx.fillRect(inputX, inputY, inputWidth, inputHeight);
                ctx.strokeStyle = isInputFocused ? '#e67e22' : '#ccc';
                ctx.lineWidth = 2;
                ctx.strokeRect(inputX, inputY, inputWidth, inputHeight);
                
                // ì…ë ¥ëœ í…ìŠ¤íŠ¸
                ctx.fillStyle = '#2c3e50';
                ctx.font = '22px "MyGameFont"';
                ctx.textAlign = 'left';
                ctx.fillText(currentNickname || 'ìµœëŒ€ 10ì', inputX + 10, inputY + 28);
                
                uiBoxes.nicknameInput = { x: inputX, y: inputY, width: inputWidth, height: inputHeight };

                if (finalRank === 'saving') {
                    drawButton(btnY, 'ìˆœìœ„ ê¸°ë¡ ì¤‘...', loadedImages.lightGrayBtn, 'black', 'saveBtn', 180, 50);
                } else {
                    
                    // ë“±ë¡í•˜ê¸° ë²„íŠ¼ (ì™¼ìª½) - lightGray/black
                    drawButton(btnY, 'ë“±ë¡í•˜ê¸°', loadedImages.lightGrayBtn, 'black', 'saveBtn', btnWidth, btnHeight, -(btnWidth / 2) - (btnGap / 2));
                    
                    // ì·¨ì†Œ/ë©”ì¸ ë²„íŠ¼ (ì˜¤ë¥¸ìª½) - darkGray/white
                    drawButton(btnY, 'ì·¨ì†Œ/ë©”ì¸', loadedImages.darkGrayBtn, 'white', 'cancelBtn', btnWidth, btnHeight, (btnWidth / 2) + (btnGap / 2));
                }
                

            } else { 
                // ìµœì¢… ìˆœìœ„ í‘œì‹œ í›„ 'ê³„ì†í•˜ê¸°' ë²„íŠ¼
                drawButton(CENTER_Y + 100, 'ê³„ì†í•˜ê¸°', loadedImages.darkGrayBtn, 'white', 'continueBtn', 180, 50); // UIë¥¼ ì•„ë˜ë¡œ ë‚´ë¦¼
            }
        }

        function drawUI(drawButton = true) {
            ctx.fillStyle = 'black'; ctx.font = '24px "MyGameFont"'; ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 15, 30);
            const gaugeWidth = 150, gaugeHeight = 20, gaugeX = 15, gaugeY = 45;
            ctx.strokeStyle = '#333'; ctx.strokeRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);
            const fillWidth = (gaugeWidth * feverScore) / FEVER_TRIGGER_COUNT;
            ctx.fillStyle = '#ff69b4'; ctx.fillRect(gaugeX, gaugeY, fillWidth, gaugeHeight);
            ctx.fillStyle = '#ff69b4'; ctx.font = '16px "MyGameFont"';
            ctx.fillText('LOVE', gaugeX + gaugeWidth + 10, gaugeY + 16);
            let hearts = '';
            for (let i = 0; i < MAX_LIVES; i++) hearts += (i < lives) ? 'â¤ï¸' : 'ğŸ–¤';
            ctx.font = '24px Arial'; ctx.textAlign = 'left';
            ctx.fillText(hearts, 15, gaugeY + gaugeHeight + 25);
            if (isFeverTime) { ctx.fillStyle = 'orange'; ctx.font = 'bold 36px "MyGameFont"'; ctx.textAlign = 'center'; ctx.fillText(`CLOVER TIME!`, GAME_WIDTH / 2, 120); ctx.fillText(`${(feverTimer / 1000).toFixed(1)}s`, GAME_WIDTH / 2, 160); }
            if (drawButton) { 
                const btnSize = 40, margin = 15, btnX = GAME_WIDTH - btnSize - margin, btnY = margin; 
                uiBoxes.pauseButtonBox = { x: btnX, y: btnY, width: btnSize, height: btnSize }; 
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(btnX, btnY, btnSize, btnSize); 
                ctx.fillStyle = 'white'; ctx.fillRect(btnX + 10, btnY + 10, 7, 20); ctx.fillRect(btnX + 23, btnY + 10, 7, 20); 
            }
        }

        function drawErrorScreen() {
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.fillStyle = '#ff4d4d'; ctx.font = 'bold 28px "MyGameFont"'; ctx.textAlign = 'center';
            ctx.fillText('! ì˜¤ë¥˜ ë°œìƒ !', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 120);
            ctx.fillStyle = 'white'; ctx.font = '18px "MyGameFont"';
            ctx.fillText('ê²Œì„ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 60);
            if (loadingError) {
                ctx.fillStyle = '#cccccc'; ctx.font = '14px monospace';
                const errorString = loadingError.toString(); const maxWidth = GAME_WIDTH - 40;
                let words = errorString.split(' '); let line = ''; let y = GAME_HEIGHT / 2;
                for(let n = 0; n < words.length; n++) {
                    let testLine = line + words[n] + ' ';
                    if (ctx.measureText(testLine).width > maxWidth && n > 0) { ctx.fillText(line, GAME_WIDTH / 2, y); line = words[n] + ' '; y += 20; } 
                    else { line = testLine; }
                }
                ctx.fillText(line, GAME_WIDTH / 2, y);
            }
            ctx.fillStyle = 'white'; ctx.font = '16px "MyGameFont"'; ctx.fillText('ì•„ë˜ ì‚¬í•­ì„ í™•ì¸í•´ì£¼ì„¸ìš”:', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 60);
            ctx.fillStyle = '#cccccc'; ctx.font = '14px "MyGameFont"';
            ctx.fillText('- íŒŒì¼ ì´ë¦„ì˜ ëŒ€ì†Œë¬¸ìê°€ ì •í™•í•œì§€ í™•ì¸', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 90);
            ctx.fillText('- ëª¨ë“  ì´ë¯¸ì§€/ì‚¬ìš´ë“œ/í°íŠ¸ íŒŒì¼ì´ ìˆëŠ”ì§€ í™•ì¸', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 115);
        }

        function drawStartScreen() { 
            // drawMainMenuì—ì„œ uiBoxesë¥¼ ì´ˆê¸°í™”í•˜ê³  ë°°ê²½ì„ ê·¸ë¦½ë‹ˆë‹¤.
            if (startScreenState === 'main') drawMainMenu(); 
            else if (startScreenState === 'leaderboard') drawLeaderboardScreen(); 
            else if (startScreenState === 'characterSelect') drawCharacterSelectScreen(); 
            else if (startScreenState === 'credit') drawCreditScreen(); 
            drawMuteButton(); // ëª¨ë“  ì‹œì‘ í™”ë©´ì— ìŒì†Œê±° ë²„íŠ¼ í‘œì‹œ
        }

        function drawCurrentState() {
            const bgColor = (gameState === 'playing' && isFeverTime) ? '#e8f5e9' : '#f0f0f0';
            canvas.style.backgroundColor = bgColor;
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.fillStyle = bgColor; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            switch(gameState) {
                case 'loading': ctx.fillStyle = 'black'; ctx.font = '24px "MyGameFont"'; ctx.textAlign = 'center'; ctx.fillText('ë¡œë”© ì¤‘...', GAME_WIDTH / 2, GAME_HEIGHT / 2); break;
                case 'error': drawErrorScreen(); break;
                case 'startScreen': drawStartScreen(); break;
                case 'playing': drawObjects(); drawPlayer(); drawGround(); drawUI(); drawMuteButton(); break;
                case 'paused': drawObjects(); drawPlayer(); drawGround(); drawUI(false); drawPauseScreen(); drawMuteButton(); break;
                case 'gameOver': drawObjects(); drawPlayer(); drawGround(); drawGameOver(); drawMuteButton(); break;
            }
        }
        
        // --- ìœ í‹¸ë¦¬í‹° ë° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---
        function getEventPos(e) { const rect = canvas.getBoundingClientRect(); const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; return { x: (clientX - rect.left) / rect.width * GAME_WIDTH, y: (clientY - rect.top) / rect.height * GAME_HEIGHT }; }
        function isInside(pos, rect) { return rect && pos.x > rect.x && pos.x < rect.x + rect.width && pos.y > rect.y && pos.y < rect.y + rect.height; }
        function setRealViewportHeight() { document.body.style.height = `${window.innerHeight}px`; }
        function resizeCanvas() { 
            const vpWidth = window.innerWidth, vpHeight = window.innerHeight; 
            const scale = Math.min(vpWidth / GAME_WIDTH, vpHeight / GAME_HEIGHT); 
            canvas.style.width = `${GAME_WIDTH * scale}px`; 
            canvas.style.height = `${GAME_HEIGHT * scale}px`; 
            const dpr = window.devicePixelRatio || 1; 
            canvas.width = GAME_WIDTH * dpr; 
            canvas.height = GAME_HEIGHT * dpr; 
            ctx.scale(dpr, dpr); 
            
            drawCurrentState(); 
        }
        
        async function saveAndGetRank(currentScore, nickname) {
            try {
                finalRank = 'saving';
                // ìˆœìœ„ ê³„ì‚° ëŒ€ê¸° ì¤‘ì—ë„ UI ì—…ë°ì´íŠ¸
                drawCurrentState(); 

                await saveToLeaderboard(currentScore, nickname);
                const higherScoresSnapshot = await leaderboardCollection.where("score", ">", currentScore).get();
                finalRank = higherScoresSnapshot.size + 1;
            } catch (error) {
                console.error("ìˆœìœ„ ê³„ì‚° ì˜¤ë¥˜:", error);
                finalRank = "??"; 
            } finally {
                 drawCurrentState();
            }
        }

        // [ìˆ˜ì •] ë°°ê²½ìŒ ì¬ìƒ ì•ˆì •ì„± ê°•í™”ë¥¼ ìœ„í•´ AudioContext í™œì„±í™” ë¡œì§ì„ ìµœì í™”
        function initAudioContext(forcePlay = false) {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            // AudioContext í™œì„±í™” (resume) ì‹œë„
            if (audioContext.state === 'suspended' || audioContext.state === 'closed') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully.');
                    hasInteracted = true;
                    // BGM ì¬ìƒì„ ë³„ë„ì˜ setTimeoutìœ¼ë¡œ ë˜í•‘í•˜ì—¬ ì˜¤ë””ì˜¤ ì²˜ë¦¬ ì§€ì—° ì‹œê°„ì„ í™•ë³´
                    setTimeout(() => {
                        if (!isMuted && (hasInteracted || forcePlay)) { 
                            bgm.volume = forcePlay ? BGM_VOLUME_NORMAL : BGM_VOLUME_MENU;
                            bgm.play().catch(e => console.log("BGM play failed after AudioContext resume (delayed):", e));
                        }
                    }, 0);
                }).catch(e => {
                    console.error("AudioContext resume failed:", e);
                    if (!forcePlay) hasInteracted = false; 
                });
            } else {
                 hasInteracted = true;
                 setTimeout(() => {
                    if (!isMuted && (hasInteracted || forcePlay)) {
                        bgm.volume = forcePlay ? BGM_VOLUME_NORMAL : BGM_VOLUME_MENU;
                        bgm.play().catch(e => console.log("BGM play failed in running context (delayed):", e));
                    }
                 }, 0);
            }
        }
        
        async function handleInteractionStart(e) {
            e.preventDefault();
            const pos = getEventPos(e);

            // [ìµœì í™”] ìµœì´ˆ í„°ì¹˜ ì‹œ AudioContext í™œì„±í™” ì‹œë„ë¥¼ í„°ì¹˜ ì´ë²¤íŠ¸ì˜ ë™ê¸°ì  ë¶€ë¶„ì—ì„œ ì‹¤í–‰
            if (!hasInteracted) {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // AudioContext.resume()ì€ ì‚¬ìš©ì ìƒí˜¸ì‘ìš© ë‚´ì—ì„œ í˜¸ì¶œë˜ì–´ì•¼ ê°€ì¥ ì„±ê³µë¥ ì´ ë†’ìŠµë‹ˆë‹¤.
                if (audioContext.state === 'suspended' || audioContext.state === 'closed') {
                    audioContext.resume().then(() => {
                        console.log('AudioContext resumed successfully on first interaction.');
                        hasInteracted = true;
                        if (!isMuted) {
                             bgm.volume = BGM_VOLUME_MENU;
                             bgm.play().catch(e => console.log("Menu BGM play failed after resume:", e));
                        }
                    }).catch(e => {
                        console.error("AudioContext resume failed:", e);
                    });
                } else {
                    hasInteracted = true; // ì´ë¯¸ running ìƒíƒœì¸ ê²½ìš° ìƒí˜¸ì‘ìš© í”Œë˜ê·¸ë§Œ ì„¤ì •
                    if (!isMuted && bgm.paused) {
                        bgm.volume = BGM_VOLUME_MENU;
                        bgm.play().catch(e => console.log("Menu BGM play failed in running state:", e));
                    }
                }
            }
            
            // ê²Œì„ ì˜¤ë²„ ìƒíƒœê°€ ì•„ë‹ ë•ŒëŠ” ë„¤ì´í‹°ë¸Œ Input í¬ì»¤ìŠ¤ í•´ì œ
            if (gameState !== 'gameOver') {
                 nativeInput.blur();
                 isInputFocused = false;
            }
            
            if (uiBoxes.muteBtn && isInside(pos, uiBoxes.muteBtn)) { 
                isMuted = !isMuted; 
                bgm.muted = isMuted; 
                if (isMuted) {
                    bgm.pause();
                    if (audioContext) audioContext.suspend();
                } else {
                    // ìŒì†Œê±° í•´ì œ ì‹œ í˜„ì¬ ìƒíƒœì— ë§ëŠ” ë³¼ë¥¨ìœ¼ë¡œ ì¬ìƒ ì‹œë„
                    bgm.volume = gameState === 'playing' ? BGM_VOLUME_NORMAL : BGM_VOLUME_MENU;
                    // initAudioContextë¥¼ í˜¸ì¶œí•˜ì—¬ AudioContextë¥¼ resume ìƒíƒœë¡œ ìœ ì§€í•˜ë©° BGM ì¬ìƒì„ ì‹œë„í•©ë‹ˆë‹¤.
                    initAudioContext(gameState === 'playing'); 
                }
                drawCurrentState(); 
                return; 
            }

            if (gameState === 'startScreen') {
                bgm.volume = BGM_VOLUME_MENU;
                if (startScreenState === 'main') {
                    if (isInside(pos, uiBoxes.charSelectBtn)) { playSound(SOUND_ASSETS.buttonClick); startScreenState = 'characterSelect'; }
                    else if (isInside(pos, uiBoxes.leaderboardBtn)) { playSound(SOUND_ASSETS.buttonClick); leaderboardScrollY = 0; startScreenState = 'leaderboard'; }
                    else if (isInside(pos, uiBoxes.startBtn)) { playSound(SOUND_ASSETS.buttonClick); init(); } // init()ì—ì„œ BGM ê°•ì œ ì¬ìƒ
                    else if (isInside(pos, uiBoxes.creditBtn)) { playSound(SOUND_ASSETS.buttonClick); startScreenState = 'credit'; }
                    
                    
                } else {
                    if (startScreenState === 'characterSelect') { 
                        uiBoxes.characterBoxes.forEach(box => { 
                            if (isInside(pos, box) && selectedCharacterId !== box.id) { selectedCharacterId = box.id; playSound(characters.find(c => c.id === selectedCharacterId).selectSfxSrc); }
                        }); 
                    }
                    if (isInside(pos, uiBoxes.confirmBtn)) { playSound(SOUND_ASSETS.buttonClick); startScreenState = 'main'; leaderboardScrollY = 0; }
                    if (startScreenState === 'leaderboard') { 
                        isDragging = true; lastTouchY = pos.y; 
                        if (isInside(pos, uiBoxes.confirmBtn)) { playSound(SOUND_ASSETS.buttonClick); startScreenState = 'main'; leaderboardScrollY = 0; } 
                    }
                }
            } else if (gameState === 'playing') {
                if (uiBoxes.pauseButtonBox && isInside(pos, uiBoxes.pauseButtonBox)) { 
                    playSound(SOUND_ASSETS.buttonClick); gameState = 'paused'; bgm.pause(); 
                }
                else { player.dx = 0; targetX = pos.x - player.width / 2; }
            } else if (gameState === 'paused') {
                if (isInside(pos, uiBoxes.resumeBtn)) { 
                    playSound(SOUND_ASSETS.buttonClick); gameState = 'playing'; 
                    bgm.volume = BGM_VOLUME_NORMAL;
                    bgm.play().catch(e => console.log("BGM play failed on resume:", e)); 
                }
                else if (isInside(pos, uiBoxes.toMainBtn)) { 
                    playSound(SOUND_ASSETS.buttonClick); gameState = 'startScreen'; startScreenState = 'main'; 
                    bgm.volume = BGM_VOLUME_MENU;
                    bgm.currentTime = 0; bgm.play().catch(e => console.log("BGM play failed on return to main:", e)); 
                }
            } else if (gameState === 'gameOver') {
                // [ìˆ˜ì • 3] ìˆœìœ„ ê³„ì‚° ì—¬ë¶€ì™€ ìƒê´€ì—†ì´ ë‹‰ë„¤ì„ ì…ë ¥/ë²„íŠ¼ í´ë¦­ ê°€ëŠ¥
                if (finalRank === null || finalRank === 'saving') { 
                    if (uiBoxes.nicknameInput && isInside(pos, uiBoxes.nicknameInput)) {
                        // ìº”ë²„ìŠ¤ ì…ë ¥ í•„ë“œ í„°ì¹˜ ì‹œ, ë„¤ì´í‹°ë¸Œ inputì— í¬ì»¤ìŠ¤
                        isInputFocused = true;
                        nativeInput.focus();
                        drawCurrentState();
                    } else if (uiBoxes.saveBtn && isInside(pos, uiBoxes.saveBtn)) {
                        nativeInput.blur();
                        isInputFocused = false;
                        const nickname = currentNickname.trim();
                        if (nickname) {
                            // ìˆœìœ„ ê³„ì‚° ì¤‘ì´ë”ë¼ë„ ë“±ë¡ ì‹œì‘
                            saveAndGetRank(score, nickname);
                        } else {
                            resetToMainMenu();
                        }
                    } else if (uiBoxes.cancelBtn && isInside(pos, uiBoxes.cancelBtn)) {
                        nativeInput.blur();
                        isInputFocused = false;
                        resetToMainMenu();
                    } else {
                        nativeInput.blur();
                        isInputFocused = false;
                    }
                } else if (finalRank !== 'saving' && uiBoxes.continueBtn && isInside(pos, uiBoxes.continueBtn)) {
                    resetToMainMenu();
                }
            }
        }
        
        function resetToMainMenu() {
            // [ìš”ì²­ 5] ê²Œì„ í”Œë ˆì´ í›„ ë³µê·€ ì‹œ í”Œë˜ê·¸ ì„¤ì •
            hasPlayedOnce = true;
            
            gameState = 'startScreen'; 
            startScreenState = 'main'; 
            finalRank = null;
            preliminaryRank = null;
            currentNickname = ''; 
            nativeInput.value = '';
            nativeInput.blur();
            bgm.volume = BGM_VOLUME_MENU;
            bgm.currentTime = 0; 
            bgm.play().catch(e => console.log("BGM play failed on game over exit/cancel:", e));
        }


        function handleInteractionMove(e) { 
            e.preventDefault(); 
            const pos = getEventPos(e); 
            if (gameState === 'startScreen' && startScreenState === 'leaderboard' && isDragging) { 
                const deltaY = pos.y - lastTouchY; 
                leaderboardScrollY += deltaY; 
                lastTouchY = pos.y; 
            } else if (gameState === 'playing') { 
                player.dx = 0; targetX = pos.x - player.width / 2; 
            } 
        }

        function handleInteractionEnd(e) { 
            isDragging = false; 
        }

        // í‚¤ë³´ë“œ ì…ë ¥ì€ ë„¤ì´í‹°ë¸Œ inputì˜ 'input' ì´ë²¤íŠ¸ë¡œ ì²˜ë¦¬ë˜ë¯€ë¡œ, í‚¤ë‹¤ìš´ í•¸ë“¤ëŸ¬ëŠ” ë‹¨ìˆœí™”
        function handleKeyDown(e) { 
            if (gameState === 'playing') {
                if (e.key === 'ArrowRight' || e.key === 'Right') player.dx = player.speed; 
                else if (e.key === 'ArrowLeft' || e.key === 'Left') player.dx = -player.speed;
            } else if (gameState === 'gameOver' && (finalRank === null || finalRank === 'saving') && isInputFocused) {
                 // ë„¤ì´í‹°ë¸Œ ì¸í’‹ì´ í¬ì»¤ìŠ¤ëœ ê²½ìš°, ESC í‚¤ ì™¸ì—ëŠ” ë¸Œë¼ìš°ì €ê°€ ì²˜ë¦¬í•˜ë„ë¡ ë‘¡ë‹ˆë‹¤.
                 if (e.key === 'Escape') {
                    nativeInput.blur(); // ESC ëˆ„ë¥´ë©´ í¬ì»¤ìŠ¤ í•´ì œ
                    resetToMainMenu();
                 }
            }
        }
        
        function handleKeyUp(e) { 
            if (gameState === 'playing' && (e.key === 'ArrowRight' || e.key === 'Right' || e.key === 'ArrowLeft' || e.key === 'Left')) {
                player.dx = 0; 
            }
        }

        function handleWheel(e) { 
            if (gameState === 'startScreen' && startScreenState === 'leaderboard') { 
                e.preventDefault(); 
                leaderboardScrollY -= e.deltaY * 0.5; 
            } 
        }
        
        // [ì¶”ê°€] ë„¤ì´í‹°ë¸Œ input ë³€ê²½ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
        nativeInput.addEventListener('input', () => {
            currentNickname = nativeInput.value;
            drawCurrentState();
        });

        // [ì¶”ê°€] ë„¤ì´í‹°ë¸Œ input í¬ì»¤ìŠ¤ í•´ì œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
        nativeInput.addEventListener('blur', () => {
            if (gameState === 'gameOver' && (finalRank === null || finalRank === 'saving')) {
                isInputFocused = false;
                drawCurrentState();
            }
        });

        // ==================================================================
        // ë©”ì¸ ê²Œì„ ë£¨í”„ ë° ì‹œì‘ì  (Main Loop & Entry Point)
        // ==================================================================
        function gameLoop(timestamp) {
            sfxPlayedThisFrame = 0;
            cancelAnimationFrame(animationFrameId);
            
            // [ìš”ì²­ 4] ê¹œë¹¡ì„ íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
            blinkTimer = (timestamp % 2000) / 2000; 

            if (gameState === 'loading' || gameState === 'error') { drawCurrentState(); animationFrameId = requestAnimationFrame(gameLoop); return; }
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            if (gameState === 'playing') { updateObjects(deltaTime); movePlayer(); }
            drawCurrentState();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        async function main() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            audioContext.suspend().catch(e => console.log("Initial AudioContext suspend failed:", e));

            initializeFirebase();
            setRealViewportHeight();
            bgm.volume = BGM_VOLUME_MENU;
            resizeCanvas(); 
            try {
                await loadGameAssets();
                listenForLeaderboardUpdates();
                gameState = 'startScreen';
            } catch (error) {
                console.error(error);
                loadingError = error;
                gameState = 'error';
            }
            gameLoop(0);
        }
        
        window.addEventListener('resize', () => { setRealViewportHeight(); resizeCanvas(); });
        document.addEventListener('visibilitychange', () => { 
            if (document.hidden && gameState === 'playing') { 
                gameState = 'paused'; bgm.pause(); 
                if (audioContext) audioContext.suspend();
            } else if (!document.hidden && (gameState === 'playing' || gameState === 'paused') && !isMuted) {
                bgm.volume = gameState === 'playing' ? BGM_VOLUME_NORMAL : BGM_VOLUME_MENU;
                bgm.play().catch(e => console.log("BGM play failed on visibility change:", e));
                if (audioContext) audioContext.resume().catch(e => console.log("AudioContext resume failed on visibility change:", e));
            }
        });
        
        // [ìˆ˜ì •] ìµœì´ˆ í„°ì¹˜ ì‹œ ë°°ê²½ìŒì´ ì¬ìƒë˜ì§€ ì•Šë”ë¼ë„ hasInteractedëŠ” ì„¤ì •ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
        // ë”°ë¼ì„œ touch/click ì´ë²¤íŠ¸ëŠ” hasInteracted í”Œë˜ê·¸ë¥¼ ì„¤ì •í•˜ê³  AudioContextë¥¼ í™œì„±í™”í•˜ëŠ” ì—­í• ë§Œ ìˆ˜í–‰í•©ë‹ˆë‹¤.
        canvas.addEventListener('touchstart', handleInteractionStart, { passive: false });
        canvas.addEventListener('touchmove', handleInteractionMove, { passive: false });
        canvas.addEventListener('touchend', handleInteractionEnd);
        canvas.addEventListener('mousedown', handleInteractionStart);
        canvas.addEventListener('mousemove', handleInteractionMove);
        canvas.addEventListener('mouseup', handleInteractionEnd);
        
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        canvas.addEventListener('wheel', handleWheel, { passive: false });

        main();
    </script>
</body>
</html>
