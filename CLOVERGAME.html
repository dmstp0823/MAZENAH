<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>YEAH! We Are CLOVERs!</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üçÄ</text></svg>">
    <style>
        @font-face {
            font-family: 'MyGameFont';
            src: url('./fonts/Pak_Yong_jun.ttf') format('truetype');
        }
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <audio id="bgm" src="./Love3.mp3" loop></audio>

    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

    <script>
        // ==================================================================
        // Í≤åÏûÑ ÏÑ§Ï†ï (Constants & Config)
        // ==================================================================
        const GAME_WIDTH = 540;
        const GAME_HEIGHT = 960;
        const MAX_LIVES = 3;
        const BGM_VOLUME_NORMAL = 0.5;
        const BGM_VOLUME_MENU = BGM_VOLUME_NORMAL / 2;
        const FEVER_DURATION = 5000;
        const FEVER_TRIGGER_COUNT = 10;
        const BASE_SPAWN_INTERVAL = 450;
        const FEVER_SPAWN_INTERVAL = 120;
        const SFX_POOL_SIZE = 5;
        const OBJECT_POOL_SIZE = 100;
        const MAX_SFX_PER_FRAME = 3; 

        const FIREBASE_CONFIG = {
            apiKey: "ÏÉàÎ°ú Î∞úÍ∏âÎ∞õÏùÄ ÌÇ§ Î¨∏ÏûêÏó¥",
            authDomain: "clovergame-e712f.firebaseapp.com",
            projectId: "clovergame-e712f",
            storageBucket: "clovergame-e712f.appspot.com",
            messagingSenderId: "525191060039",
            appId: "1:525191060039:web:5707417e6e8ee8bf9cef62"
        };
        
        const characters = [
            { id: 1, name: 'PAIIEK', speed: 7, imgSrc: './char2.png', imgSrcSelected: './char2-1.png', imgIconSrc: './char2-2.png', imgHitSrc: './char2-3.png', selectSfxSrc: './sounds/char2-1.mp3', hitSfxSrc: './sounds/char2-1-1.mp3', selectVolume: 0.9, hitVolume: 1.0 },
            { id: 2, name: 'KANG', speed: 8, imgSrc: './char3.png', imgSrcSelected: './char3-1.png', imgIconSrc: './char3-2.png', imgHitSrc: './char3-3.png', selectSfxSrc: './sounds/char3-1.mp3', hitSfxSrc: './sounds/char3-1-1.mp3', selectVolume: 1.0, hitVolume: 1.0 },
            { id: 3, name: 'NAH', speed: 9, imgSrc: './char1.png', imgSrcSelected: './char1-1.png', imgIconSrc: './char1-2.png', imgHitSrc: './char1-3.png', selectSfxSrc: './sounds/char1-1.mp3', hitSfxSrc: './sounds/char1-1-1.mp3', selectVolume: 0.4, hitVolume: 1.0 }
        ];

        const IMAGE_ASSETS = {
            clover: './clover.png', love: './love.png', bomb: './bomb.png', title: './clover_title.png',
            darkGrayBtn: './darkgray.png', lightGrayBtn: './lightgray.png', major: './major.png',
            yellow: './yellow.png', gray: './gray.png', circleBtn: './circle.png',
            soundOn: './sound_on.png', soundOff: './sound_off.png', ground: './ground.png'
        };
        const SOUND_ASSETS = {
            bombHit: './sounds/bomb_hit.mp3', buttonClick: './sounds/button_click.mp3',
            gameOver: './sounds/game_over.mp3', cloverTime: './sounds/clovertime.mp3',
            love1: './sounds/bbyong.mp3', love2: './sounds/heart.mp3', clover: './sounds/jump_low.mp3'
        };
        
        // --- Ï†ÑÏó≠ Î≥ÄÏàò (Global State) ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const bgm = document.getElementById('bgm');
        
        let db, leaderboardCollection, cachedLeaderboard = null;
        let selectedCharacterId = 1;
        let uiBoxes = {}, startScreenState = 'main'; 
        let leaderboardScrollY = 0, isDragging = false, lastTouchY = 0;
        let player, objectPool, score, spawnTimer, targetX, playerHitbox = {};
        let gameState = 'loading', loadingError = null;
        let lastTime = 0, gameSpeedMultiplier = 1;
        let feverScore = 0, isFeverTime = false, feverTimer = 0;
        let lives;
        let animationFrameId;
        let hasInteracted = false, isMuted = false;
        let finalRank = null;
        
        const loadedImages = {};
        let sfxPool = {};
        let sfxLastPlayed = {};
        let sfxPlayedThisFrame = 0;
        let audioContext;

        // ==================================================================
        // Ìï®Ïàò Ï†ïÏùò (Function Definitions)
        // ==================================================================

        // --- Ï¥àÍ∏∞Ìôî Î∞è Î¶¨ÏÜåÏä§ Î°úÎî© ---
        function initializeFirebase() { try { firebase.initializeApp(FIREBASE_CONFIG); db = firebase.firestore(); leaderboardCollection = db.collection('leaderboard'); } catch (e) { console.error("Firebase Ï¥àÍ∏∞Ìôî Ïò§Î•ò:", e); loadingError = e; gameState = 'error'; } }
        function listenForLeaderboardUpdates() { if (!leaderboardCollection) return; leaderboardCollection.orderBy('score', 'desc').limit(20).onSnapshot(snapshot => { cachedLeaderboard = []; snapshot.forEach(doc => cachedLeaderboard.push(doc.data())); }, error => { console.error("ÏàúÏúÑÌëú Ïã§ÏãúÍ∞Ñ Î°úÎî© Ïò§Î•ò: ", error); cachedLeaderboard = []; }); }
        async function saveToLeaderboard(newScore, nickname) { if (!leaderboardCollection) return; try { const character = characters.find(c => c.id === selectedCharacterId); const characterName = character ? character.name : 'Unknown'; await leaderboardCollection.add({ score: newScore, name: nickname, character: characterName }); } catch (error) { console.error("ÏàúÏúÑÌëú Ï†ÄÏû• Ïò§Î•ò: ", error); } }

        async function loadAsset(type, name, src) {
            if (type === 'image') {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.src = src;
                    img.onload = () => {
                        if (name === 'character') resolve(img);
                        else { loadedImages[name] = img; resolve(); }
                    };
                    img.onerror = () => reject(`${type} Î°úÎìú Ïã§Ìå®: ${src}`);
                });
            } else if (type === 'sound') {
                if (!audioContext) return Promise.resolve();
                return new Promise(async (resolve, reject) => {
                    try {
                        const response = await fetch(src);
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        sfxPool[src] = audioBuffer;
                        resolve();
                    } catch (e) {
                        reject(`${type} Î°úÎìú Ïã§Ìå®: ${src}, Ïò§Î•ò: ${e}`);
                    }
                });
            }
        }

        async function loadGameAssets() {
            const imagePromises = Object.entries(IMAGE_ASSETS).map(([name, src]) => loadAsset('image', name, src));
            const charImagePromises = characters.flatMap(char => [
                loadAsset('image', 'character', char.imgSrc).then(img => { char.img = img; char.originalWidth = img.naturalWidth; char.originalHeight = img.naturalHeight; }),
                loadAsset('image', 'character', char.imgSrcSelected).then(img => char.imgSelected = img),
                loadAsset('image', 'character', char.imgIconSrc).then(img => char.imgIcon = img),
                char.imgHitSrc ? loadAsset('image', 'character', char.imgHitSrc).then(img => char.imgHit = img) : Promise.resolve()
            ]);
            const soundSrcs = [...new Set([...Object.values(SOUND_ASSETS), ...characters.flatMap(c => [c.selectSfxSrc, c.hitSfxSrc])].filter(Boolean))];
            const soundPromises = soundSrcs.map(src => loadAsset('sound', null, src));
            await Promise.all([...imagePromises, ...charImagePromises, ...soundPromises, document.fonts.ready]);
        }

        function playSound(src, volume = 1.0) {
            if (!audioContext || !hasInteracted || isMuted || !sfxPool[src]) return;
            if (sfxPlayedThisFrame >= MAX_SFX_PER_FRAME) return;
            sfxPlayedThisFrame++;
            const now = performance.now();
            const cooldown = 75;
            if (src === SOUND_ASSETS.clover) {
                if (sfxLastPlayed[src] && now - sfxLastPlayed[src] < cooldown) { return; }
            }
            sfxLastPlayed[src] = now;
            const source = audioContext.createBufferSource();
            source.buffer = sfxPool[src];
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            source.start(0);
        }

        // --- Í≤åÏûÑ Î°úÏßÅ ---
        function init() { /* ... function content unchanged ... */ }
        function spawnObject() { /* ... function content unchanged ... */ }
        function movePlayer() { /* ... function content unchanged ... */ }
        function updateObjects(deltaTime) { /* ... function content unchanged ... */ }
        function handleCollision(obj) { /* ... function content unchanged ... */ }
        
        // --- Î†åÎçîÎßÅ ---
        function drawPlayer() { /* ... function content unchanged ... */ }
        function drawObjects() { /* ... function content unchanged ... */ }
        function drawConfirmButton(yPos) { /* ... function content unchanged ... */ }
        function drawGround() { /* ... function content unchanged ... */ }
        function drawMuteButton() { /* ... function content unchanged ... */ }
        function drawCreditScreen() { /* ... function content unchanged ... */ }
        function drawLeaderboardScreen() { /* ... function content unchanged ... */ }
        function drawCharacterSelectScreen() { /* ... function content unchanged ... */ }
        function drawMainMenu() { /* ... function content unchanged ... */ }
        function drawPauseScreen() { /* ... function content unchanged ... */ }
        function drawGameOver() { /* ... function content unchanged ... */ }
        function drawUI(drawButton = true) { /* ... function content unchanged ... */ }
        function drawErrorScreen() { /* ... function content unchanged ... */ }
        function drawStartScreen() { /* ... function content unchanged ... */ }
        function drawCurrentState() { /* ... function content unchanged ... */ }
        
        // --- Ïú†Ìã∏Î¶¨Ìã∞ Î∞è Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ ---
        function getEventPos(e) { /* ... function content unchanged ... */ }
        function isInside(pos, rect) { /* ... function content unchanged ... */ }
        function setRealViewportHeight() { /* ... function content unchanged ... */ }
        function resizeCanvas() { /* ... function content unchanged ... */ }
        
        async function saveAndGetRank(currentScore, nickname) {
            try {
                finalRank = 'saving';
                await saveToLeaderboard(currentScore, nickname);
                const higherScoresSnapshot = await leaderboardCollection.where("score", ">", currentScore).get();
                finalRank = higherScoresSnapshot.size + 1;
            } catch (error) {
                console.error("ÏàúÏúÑ Í≥ÑÏÇ∞ Ïò§Î•ò:", error);
                finalRank = "??"; 
            }
        }

        function handleInteractionStart(e) {
            e.preventDefault();
            const pos = getEventPos(e);
            if (!hasInteracted) {
                hasInteracted = true;
                const resumeAudio = async () => {
                    try {
                        if (audioContext && audioContext.state === 'suspended') {
                            await audioContext.resume();
                        }
                        await bgm.play();
                    } catch (error) {
                        console.error("Ïò§ÎîîÏò§ ÌôúÏÑ±Ìôî Ïã§Ìå®:", error);
                        hasInteracted = false; 
                    }
                };
                resumeAudio();
            }
            if (uiBoxes.muteBtn && isInside(pos, uiBoxes.muteBtn)) { isMuted = !isMuted; bgm.muted = isMuted; drawCurrentState(); return; }
            if (gameState === 'startScreen') {
                if (startScreenState === 'main') {
                    if (isInside(pos, uiBoxes.charSelectBtn)) { playSound(SOUND_ASSETS.buttonClick); startScreenState = 'characterSelect'; }
                    else if (isInside(pos, uiBoxes.leaderboardBtn)) { playSound(SOUND_ASSETS.buttonClick); leaderboardScrollY = 0; startScreenState = 'leaderboard'; }
                    else if (isInside(pos, uiBoxes.startBtn)) { playSound(SOUND_ASSETS.buttonClick); init(); }
                    else if (isInside(pos, uiBoxes.creditBtn)) { playSound(SOUND_ASSETS.buttonClick); startScreenState = 'credit'; }
                } else {
                    if (startScreenState === 'characterSelect') { 
                        uiBoxes.characterBoxes.forEach(box => { 
                            if (isInside(pos, box) && selectedCharacterId !== box.id) { selectedCharacterId = box.id; const char = characters.find(c => c.id === selectedCharacterId); if (char) playSound(char.selectSfxSrc, char.selectVolume); }
                        }); 
                    }
                    if (isInside(pos, uiBoxes.confirmBtn)) { playSound(SOUND_ASSETS.buttonClick); startScreenState = 'main'; leaderboardScrollY = 0; }
                    if (startScreenState === 'leaderboard') { isDragging = true; lastTouchY = pos.y; if (isInside(pos, uiBoxes.confirmBtn)) { playSound(SOUND_ASSETS.buttonClick); startScreenState = 'main'; leaderboardScrollY = 0; } }
                }
            } else if (gameState === 'playing') {
                if (isInside(pos, pauseButtonBox)) { playSound(SOUND_ASSETS.buttonClick); gameState = 'paused'; bgm.pause(); }
                else { player.dx = 0; targetX = pos.x - player.width / 2; }
            } else if (gameState === 'paused') {
                if (isInside(pos, uiBoxes.resumeBtn)) { playSound(SOUND_ASSETS.buttonClick); gameState = 'playing'; bgm.volume = BGM_VOLUME_NORMAL; bgm.play(); }
                else if (isInside(pos, uiBoxes.toMainBtn)) { playSound(SOUND_ASSETS.buttonClick); gameState = 'startScreen'; startScreenState = 'main'; bgm.volume = BGM_VOLUME_MENU; bgm.currentTime = 0; bgm.play(); }
            } else if (gameState === 'gameOver') {
                if (finalRank === null) {
                    const nickname = prompt(`Í≤åÏûÑ Ïò§Î≤Ñ!\nÏµúÏ¢Ö Ï†êÏàò: ${score}\n\nÏàúÏúÑÏóê Îì±Î°ùÌï† ÎãâÎÑ§ÏûÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî:`, '');
                    if (nickname && nickname.trim() !== '') {
                        saveAndGetRank(score, nickname.trim());
                    } else {
                        gameState = 'startScreen'; startScreenState = 'main'; finalRank = null;
                        bgm.volume = BGM_VOLUME_MENU; bgm.currentTime = 0; bgm.play();
                    }
                } else if (finalRank !== 'saving') {
                    gameState = 'startScreen'; startScreenState = 'main'; finalRank = null;
                    bgm.volume = BGM_VOLUME_MENU; bgm.currentTime = 0; bgm.play();
                }
            }
        }
        function handleInteractionMove(e) { e.preventDefault(); const pos = getEventPos(e); if (gameState === 'startScreen' && startScreenState === 'leaderboard' && isDragging) { const deltaY = pos.y - lastTouchY; leaderboardScrollY += deltaY; lastTouchY = pos.y; } else if (gameState === 'playing') { player.dx = 0; targetX = pos.x - player.width / 2; } }
        function handleInteractionEnd(e) { isDragging = false; }
        function handleKeyDown(e) { if (gameState !== 'playing') return; if (e.key === 'ArrowRight' || e.key === 'Right') player.dx = player.speed; else if (e.key === 'ArrowLeft' || e.key === 'Left') player.dx = -player.speed; }
        function handleKeyUp(e) { if (e.key === 'ArrowRight' || e.key === 'Right' || e.key === 'ArrowLeft' || e.key === 'Left') player.dx = 0; }
        function handleWheel(e) { if (gameState === 'startScreen' && startScreenState === 'leaderboard') { e.preventDefault(); leaderboardScrollY -= e.deltaY * 0.5; } }
        
        // ==================================================================
        // Î©îÏù∏ Í≤åÏûÑ Î£®ÌîÑ Î∞è ÏãúÏûëÏ†ê (Main Loop & Entry Point)
        // ==================================================================
        function gameLoop(timestamp) {
            sfxPlayedThisFrame = 0;
            cancelAnimationFrame(animationFrameId);
            if (gameState === 'loading' || gameState === 'error') { drawCurrentState(); animationFrameId = requestAnimationFrame(gameLoop); return; }
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            if (gameState === 'playing') { updateObjects(deltaTime); movePlayer(); }
            drawCurrentState();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        async function main() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.error("Web Audio API is not supported in this browser");
                loadingError = "Web Audio API is not supported";
                gameState = 'error';
                gameLoop(0);
                return;
            }
            initializeFirebase();
            setRealViewportHeight();
            bgm.volume = BGM_VOLUME_MENU;
            resizeCanvas(); 
            try {
                await loadGameAssets();
                listenForLeaderboardUpdates();
                gameState = 'startScreen';
            } catch (error) {
                console.error(error);
                loadingError = error;
                gameState = 'error';
            }
            gameLoop(0);
        }
        
        window.addEventListener('resize', () => { setRealViewportHeight(); resizeCanvas(); });
        document.addEventListener('visibilitychange', () => { if (document.hidden && gameState === 'playing') { gameState = 'paused'; bgm.pause(); } });
        canvas.addEventListener('touchstart', handleInteractionStart, { passive: false });
        canvas.addEventListener('touchmove', handleInteractionMove, { passive: false });
        canvas.addEventListener('touchend', handleInteractionEnd);
        canvas.addEventListener('mousedown', handleInteractionStart);
        canvas.addEventListener('mousemove', handleInteractionMove);
        canvas.addEventListener('mouseup', handleInteractionEnd);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        canvas.addEventListener('wheel', handleWheel, { passive: false });

        main();
    </script>
</body>
</html>

