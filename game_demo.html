<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ì˜¨ë¼ì¸ ìˆœìœ„ ê²½ìŸ! ë¬¼ì²´ í”¼í•˜ê¸°</title>
    <style>
        @font-face {
            font-family: 'MyGameFont';
            src: url('./fonts/Pak_Yong_jun.ttf') format('truetype');
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            cursor: pointer;
            background-color: #f0f0f0;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <audio id="bgm" src="./Love3.mp3" loop></audio>

    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

    <script>
        // ==================================================================
        // Firebase Config (ì‚¬ìš©ì ì •ë³´ë¡œ êµì²´)
        // ==================================================================
        const firebaseConfig = {
            apiKey: "AIzaSyA90s1FUPCjbW3Wo_N8IVhMUqewmXhetq0",
            authDomain: "clovergame-e712f.firebaseapp.com",
            projectId: "clovergame-e712f",
            storageBucket: "clovergame-e712f.appspot.com",
            messagingSenderId: "525191060039",
            appId: "1:525191060039:web:5707417e6e8ee8bf9cef62"
        };
        // ==================================================================

        // --- ì „ì—­ ë³€ìˆ˜ ì„ ì–¸ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const bgm = document.getElementById('bgm');
        
        const GAME_WIDTH = 540;
        const GAME_HEIGHT = 960;

        let db;
        // ... (ì´í•˜ ëª¨ë“  ë³€ìˆ˜ ì„ ì–¸ì€ ì´ì „ê³¼ ë™ì¼)
        
        // --- í•¨ìˆ˜ ì •ì˜ ---
        
        // (ë³´ë‚´ì£¼ì‹  ì½”ë“œì˜ resizeCanvas ë¡œì§ì„ ìœ ì§€)
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            let newWidth, newHeight;
            const screenRatio = viewportWidth / viewportHeight;
            const gameRatio = GAME_WIDTH / GAME_HEIGHT;

            if (screenRatio < 1) { 
                if (screenRatio > gameRatio) {
                    newHeight = viewportHeight;
                    newWidth = newHeight * gameRatio;
                } else {
                    newWidth = viewportWidth;
                    newHeight = newWidth / gameRatio;
                }
            } else { 
                newWidth = viewportWidth;
                newHeight = viewportHeight;
            }

            canvas.style.width = `${newWidth}px`;
            canvas.style.height = `${newHeight}px`;

            canvas.width = newWidth * dpr;
            canvas.height = newHeight * dpr;
            ctx.scale(dpr, dpr);

            drawCurrentState();
        }
        
        // (ì´í•˜ ëª¨ë“  í•¨ìˆ˜ëŠ” ì´ì „ê³¼ ë™ì¼í•˜ê²Œ ìœ ì§€ë©ë‹ˆë‹¤)

        // -------------------------------------------------------------------
        // ì•„ë˜ëŠ” í¸ì˜ë¥¼ ìœ„í•´ ì „ì²´ ì½”ë“œë¥¼ ë‹¤ì‹œ ì²¨ë¶€í•©ë‹ˆë‹¤.
        // -------------------------------------------------------------------
        
        let leaderboardCollection;
        let cachedLeaderboard = null;
        const characters = [ { id: 1, name: 'NAH', speed: 9, imgSrc: './char1.png', imgSrcSelected: './char1-1.png', img: null, imgSelected: null }, { id: 2, name: 'PAIIEK', speed: 7, imgSrc: './char2.png', imgSrcSelected: './char2-1.png', img: null, imgSelected: null }, { id: 3, name: 'KANG', speed: 8, imgSrc: './char3.png', imgSrcSelected: './char3-1.png', img: null, imgSelected: null } ];
        let selectedCharacterId = 1;
        let uiBoxes = {};
        let startScreenState = 'main'; 
        let leaderboardScrollY = 0;
        let isDragging = false;
        let lastTouchY = 0;
        let player, objects, score, spawnTimer, targetX;
        let gameState = 'loading';
        let lastTime = 0;
        let gameSpeedMultiplier = 1;
        let feverScore = 0, isFeverTime = false, feverTimer = 0;
        const FEVER_DURATION = 5000;
        const FEVER_TRIGGER_COUNT = 10;
        const BASE_SPAWN_INTERVAL = 450;
        const FEVER_SPAWN_INTERVAL = 120;
        let pauseButtonBox = {};
        let animationFrameId;

        function initializeFirebase() { try { firebase.initializeApp(firebaseConfig); db = firebase.firestore(); leaderboardCollection = db.collection('leaderboard'); } catch (e) { console.error("Firebase ì´ˆê¸°í™” ì˜¤ë¥˜:", e); alert("Firebase ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. firebaseConfigë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."); } }
        function listenForLeaderboardUpdates() { if (!leaderboardCollection) return; leaderboardCollection.orderBy('score', 'desc').limit(10).onSnapshot(snapshot => { const leaderboard = []; snapshot.forEach(doc => { leaderboard.push(doc.data()); }); cachedLeaderboard = leaderboard; }, error => { console.error("ìˆœìœ„í‘œ ì‹¤ì‹œê°„ ë¡œë”© ì˜¤ë¥˜: ", error); cachedLeaderboard = []; }); }
        async function saveToLeaderboard(newScore, nickname) { if (!leaderboardCollection) return; try { const character = characters.find(c => c.id === selectedCharacterId); const characterName = character ? character.name : 'Unknown'; await leaderboardCollection.add({ score: newScore, name: nickname, character: characterName }); } catch (error) { console.error("ìˆœìœ„í‘œ ì €ì¥ ì˜¤ë¥˜: ", error); } }
        function loadImages() { let promises = characters.flatMap(char => [ new Promise((resolve, reject) => { char.img = new Image(); char.img.src = char.imgSrc; char.img.onload = () => { char.originalWidth = char.img.naturalWidth; char.originalHeight = char.img.naturalHeight; resolve(); }; char.img.onerror = () => reject(`ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: ${char.imgSrc}`); }), new Promise((resolve, reject) => { char.imgSelected = new Image(); char.imgSelected.src = char.imgSrcSelected; char.imgSelected.onload = () => resolve(); char.imgSelected.onerror = () => reject(`ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: ${char.imgSrcSelected}`); }) ]); return Promise.all(promises); }

        function init() {
            const rect = canvas.getBoundingClientRect();
            const selectedCharacter = characters.find(c => c.id === selectedCharacterId);
            const displayWidth = selectedCharacter.originalWidth; const displayHeight = selectedCharacter.originalHeight; const MAX_PLAYER_SIZE = 80;
            let playerWidth = displayWidth; let playerHeight = displayHeight;
            if (playerWidth > MAX_PLAYER_SIZE || playerHeight > MAX_PLAYER_SIZE) { const aspectRatio = displayWidth / displayHeight; if (aspectRatio > 1) { playerWidth = MAX_PLAYER_SIZE; playerHeight = MAX_PLAYER_SIZE / aspectRatio; } else { playerHeight = MAX_PLAYER_SIZE; playerWidth = MAX_PLAYER_SIZE * aspectRatio; } }
            player = { width: playerWidth, height: playerHeight, x: rect.width / 2 - playerWidth / 2, y: rect.height - playerHeight - (rect.height * 0.1), speed: selectedCharacter.speed, img: selectedCharacter.img, dx: 0 };
            targetX = player.x; objects = []; score = 0; spawnTimer = 0; gameSpeedMultiplier = 1; feverScore = 0; isFeverTime = false; feverTimer = 0; gameState = 'playing'; bgm.currentTime = 0; bgm.play();
        }

        function drawCurrentState() {
            const rect = canvas.getBoundingClientRect();
            ctx.clearRect(0, 0, rect.width, rect.height);
            if (gameState === 'loading') { ctx.fillStyle = 'black'; ctx.font = '24px "MyGameFont"'; ctx.textAlign = 'center'; ctx.fillText('ë¡œë”© ì¤‘...', rect.width / 2, rect.height / 2); }
            else if (gameState === 'startScreen') { drawStartScreen(); }
            else if (gameState === 'playing') { drawObjects(); drawPlayer(); drawUI(); }
            else if (gameState === 'paused') { drawPauseScreen(); }
            else if (gameState === 'gameOver') { drawGameOver(); }
        }
        
        function getEventPos(e) { const rect = canvas.getBoundingClientRect(); const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; return { x: clientX - rect.left, y: clientY - rect.top }; }
        function isInside(pos, rect) { return rect && pos.x > rect.x && pos.x < rect.x + rect.width && pos.y > rect.y && pos.y < rect.y + rect.height; }
        function drawPlayer() { if (player && player.img) { ctx.drawImage(player.img, player.x, player.y, player.width, player.height); } }
        function drawObjects() { objects.forEach(obj => { ctx.fillStyle = obj.color; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); }); }
        function drawConfirmButton(yPos) { const rect = canvas.getBoundingClientRect(); const btnWidth = 150, btnHeight = 50; const btnX = (rect.width - btnWidth) / 2; uiBoxes.confirmBtn = { x: btnX, y: yPos, width: btnWidth, height: btnHeight }; ctx.fillStyle = '#2980b9'; ctx.fillRect(btnX, yPos, btnWidth, btnHeight); ctx.fillStyle = 'white'; ctx.font = 'bold 20px "MyGameFont"'; ctx.textAlign = 'center'; ctx.fillText('í™•ì¸', rect.width / 2, yPos + 32); }
        
        function drawLeaderboardScreen() {
            const rect = canvas.getBoundingClientRect();
            ctx.fillStyle = '#ecf0f1'; ctx.fillRect(0, 0, rect.width, rect.height);
            ctx.fillStyle = '#34495e'; ctx.font = 'bold 32px "MyGameFont"'; ctx.textAlign = 'center'; ctx.fillText('ğŸ† Top 10 ğŸ†', rect.width / 2, rect.height * 0.1);
            const listStartY = rect.height * 0.15; const listHeight = rect.height * 0.7; const boxWidth = Math.min(rect.width * 0.8, 350); const boxHeight = 40, gap = 10;
            if (cachedLeaderboard === null) { ctx.font = '20px "MyGameFont"'; ctx.fillText('ë¡œë”© ì¤‘...', rect.width / 2, listStartY + 50); }
            else if (cachedLeaderboard.length === 0) { ctx.font = '20px "MyGameFont"'; ctx.fillText('ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤!', rect.width / 2, listStartY + 50); }
            else { const leaderboardTotalHeight = cachedLeaderboard.length * (boxHeight + gap) - gap; const maxScroll = 0; const minScroll = -Math.max(0, leaderboardTotalHeight - listHeight); if (leaderboardScrollY > maxScroll) leaderboardScrollY = maxScroll; if (leaderboardScrollY < minScroll) leaderboardScrollY = minScroll;
                ctx.save(); ctx.beginPath(); ctx.rect(0, listStartY, rect.width, listHeight); ctx.clip();
                cachedLeaderboard.forEach((entry, index) => {
                    const boxY = listStartY + index * (boxHeight + gap) + leaderboardScrollY;
                    ctx.fillStyle = index < 3 ? '#f1c40f' : '#bdc3c7'; ctx.fillRect((rect.width - boxWidth) / 2, boxY, boxWidth, boxHeight);
                    ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 18px "MyGameFont"'; const rankTextX = (rect.width - boxWidth) / 2 + 20;
                    const character = characters.find(c => c.name === entry.character); const charColor = character ? character.color : '#7f8c8d';
                    const charBoxSize = 18; const charBoxX = rankTextX + 35; ctx.fillStyle = charColor; ctx.fillRect(charBoxX, boxY + (boxHeight - charBoxSize) / 2, charBoxSize, charBoxSize);
                    ctx.fillStyle = '#2c3e50'; ctx.textAlign = 'left'; ctx.fillText(`${index + 1}.`, rankTextX, boxY + 25);
                    ctx.fillText(entry.name, charBoxX + charBoxSize + 10, boxY + 25);
                    ctx.textAlign = 'right'; ctx.fillText(entry.score, (rect.width + boxWidth) / 2 - 20, boxY + 25);
                });
                ctx.restore();
            }
            drawConfirmButton(rect.height * 0.9);
        }
        
        function drawCharacterSelectScreen() {
            const rect = canvas.getBoundingClientRect();
            ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 32px "MyGameFont"'; ctx.textAlign = 'center'; ctx.fillText('ìºë¦­í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”', rect.width / 2, rect.height * 0.15);
            const displayCharSize = Math.min(rect.width / 4, 100); const gap = 20;
            const totalWidth = (displayCharSize * characters.length) + (gap * (characters.length - 1));
            let startX = (rect.width - totalWidth) / 2;
            const boxY = (rect.height - displayCharSize) / 2 - 50;
            uiBoxes.characterBoxes = [];
            characters.forEach(char => {
                let imgToDraw = (char.id === selectedCharacterId) ? char.imgSelected : char.img;
                let imgDrawWidth = displayCharSize; let imgDrawHeight = displayCharSize;
                if (char.originalWidth && char.originalHeight) { const aspectRatio = char.originalWidth / char.originalHeight; if (aspectRatio > 1) { imgDrawHeight = displayCharSize / aspectRatio; } else { imgDrawWidth = displayCharSize * aspectRatio; } }
                const imgDrawX = startX + (displayCharSize - imgDrawWidth) / 2; const imgDrawY = boxY + (displayCharSize - imgDrawHeight) / 2;
                ctx.fillStyle = '#ecf0f1'; ctx.fillRect(startX, boxY, displayCharSize, displayCharSize);
                if (imgToDraw) { ctx.drawImage(imgToDraw, imgDrawX, imgDrawY, imgDrawWidth, imgDrawHeight); }
                ctx.fillStyle = '#2c3e50'; ctx.font = '20px "MyGameFont"'; ctx.fillText(char.name, startX + displayCharSize / 2, boxY + displayCharSize + 30);
                uiBoxes.characterBoxes.push({ id: char.id, x: startX, y: boxY, width: displayCharSize, height: displayCharSize });
                startX += displayCharSize + gap;
            });
            drawConfirmButton(rect.height * 0.8);
        }

        function drawMainMenu() {
            const rect = canvas.getBoundingClientRect();
            const titleFontSize = Math.min(rect.width * 0.1, 48);
            ctx.fillStyle = '#2c3e50'; ctx.font = `bold ${titleFontSize}px "MyGameFont"`; ctx.textAlign = 'center';
            ctx.fillText('ë¬¼ì²´ í”¼í•˜ê¸° ê²Œì„', rect.width / 2, rect.height * 0.2);
            const btnWidth = Math.min(rect.width * 0.7, 300); const btnHeight = Math.min(rect.height * 0.1, 60); const gap = btnHeight * 0.5;
            const totalBtnBlockHeight = (btnHeight * 3) + (gap * 2); const btnX = (rect.width - btnWidth) / 2;
            let startY = (rect.height - totalBtnBlockHeight) * 0.6;
            if (startY < rect.height * 0.3) { startY = rect.height * 0.3; }
            const btnFontSize = Math.min(btnHeight * 0.4, 24); ctx.font = `bold ${btnFontSize}px "MyGameFont"`;
            uiBoxes.charSelectBtn = { x: btnX, y: startY, width: btnWidth, height: btnHeight };
            ctx.fillStyle = '#2ecc71'; ctx.fillRect(btnX, startY, btnWidth, btnHeight); ctx.fillStyle = 'white'; ctx.fillText('ìºë¦­í„° ì„ íƒ', rect.width / 2, startY + btnHeight / 2 + (btnFontSize / 3));
            uiBoxes.leaderboardBtn = { x: btnX, y: startY + btnHeight + gap, width: btnWidth, height: btnHeight };
            ctx.fillStyle = '#e67e22'; ctx.fillRect(btnX, startY + btnHeight + gap, btnWidth, btnHeight); ctx.fillStyle = 'white'; ctx.fillText('ìˆœìœ„ ë³´ê¸°', rect.width / 2, startY + btnHeight + gap + btnHeight / 2 + (btnFontSize / 3));
            uiBoxes.startBtn = { x: btnX, y: startY + (btnHeight + gap) * 2, width: btnWidth, height: btnHeight };
            ctx.fillStyle = '#3498db'; ctx.fillRect(btnX, startY + (btnHeight + gap) * 2, btnWidth, btnHeight); ctx.fillStyle = 'white'; ctx.fillText('ê²Œì„ ì‹œì‘', rect.width / 2, startY + (btnHeight + gap) * 2 + btnHeight / 2 + (btnFontSize / 3));
        }
        
        function drawStartScreen() { uiBoxes = {}; const rect = canvas.getBoundingClientRect(); ctx.fillStyle = '#ecf0f1'; ctx.fillRect(0, 0, rect.width, rect.height); if (startScreenState === 'main') { drawMainMenu(); } else if (startScreenState === 'leaderboard') { drawLeaderboardScreen(); } else if (startScreenState === 'characterSelect') { drawCharacterSelectScreen(); } }
        function drawPauseScreen() { const rect = canvas.getBoundingClientRect(); drawObjects(); drawPlayer(); drawUI(false); ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(0, 0, rect.width, rect.height); ctx.fillStyle = 'white'; ctx.font = 'bold 48px "MyGameFont"'; ctx.textAlign = 'center'; ctx.fillText('ì¼ì‹œì •ì§€', rect.width / 2, rect.height / 2); ctx.font = '24px "MyGameFont"'; ctx.fillText('í™”ë©´ì„ ëˆŒëŸ¬ ë‹¤ì‹œ ì‹œì‘', rect.width / 2, rect.height / 2 + 50); }
        function drawGameOver() { const rect = canvas.getBoundingClientRect(); ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, rect.width, rect.height); ctx.fillStyle = 'white'; ctx.font = 'bold 40px "MyGameFont"'; ctx.textAlign = 'center'; ctx.fillText('GAME OVER', rect.width / 2, rect.height / 2 - 40); ctx.font = '24px "MyGameFont"'; ctx.fillText(`Final Score: ${score}`, rect.width / 2, rect.height / 2); ctx.font = '20px "MyGameFont"'; ctx.fillText('Tap to Save Score', rect.width / 2, rect.height / 2 + 40); }

        function drawUI(drawButton = true) {
            const rect = canvas.getBoundingClientRect();
            ctx.fillStyle = 'black'; ctx.font = '24px "MyGameFont"'; ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 15, 30);
            const gaugeWidth = 150, gaugeHeight = 20, gaugeX = 15, gaugeY = 45;
            ctx.strokeStyle = '#333'; ctx.strokeRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);
            const fillWidth = (gaugeWidth * feverScore) / FEVER_TRIGGER_COUNT;
            ctx.fillStyle = '#2ecc71'; ctx.fillRect(gaugeX, gaugeY, fillWidth, gaugeHeight);
            ctx.fillStyle = 'black'; ctx.font = '16px "MyGameFont"';
            ctx.fillText('FEVER', gaugeX + gaugeWidth + 10, gaugeY + 16);
            if (isFeverTime) {
                ctx.fillStyle = 'orange'; ctx.font = 'bold 36px "MyGameFont"'; ctx.textAlign = 'center';
                ctx.fillText(`FEVER TIME!`, rect.width / 2, 50);
                ctx.fillText(`${(feverTimer / 1000).toFixed(1)}s`, rect.width / 2, 90);
            }
            if (drawButton) {
                const btnSize = 40, margin = 15;
                const btnX = rect.width - btnSize - margin; const btnY = margin;
                pauseButtonBox = { x: btnX, y: btnY, width: btnSize, height: btnSize };
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(btnX, btnY, btnSize, btnSize);
                ctx.fillStyle = 'white'; ctx.fillRect(btnX + 10, btnY + 10, 7, 20); ctx.fillRect(btnX + 23, btnY + 10, 7, 20);
            }
        }

        function movePlayer() { const rect = canvas.getBoundingClientRect(); if (player.dx !== 0) { player.x += player.dx; targetX = player.x; } else { player.x += (targetX - player.x) * 0.5; } if (player.x < 0) player.x = 0; if (player.x + player.width > rect.width) player.x = rect.width - player.width; }
        function updateObjects(deltaTime) {
            const rect = canvas.getBoundingClientRect();
            spawnTimer += deltaTime;
            gameSpeedMultiplier = 1 + (score * 0.01);
            if (isFeverTime) {
                feverTimer -= deltaTime; if (feverTimer <= 0) isFeverTime = false;
                if (spawnTimer > FEVER_SPAWN_INTERVAL / gameSpeedMultiplier) { objects.push({ x: Math.random() * (rect.width - 25), y: -25, width: 25, height: 25, speed: 200, type: 'good', color: 'red' }); spawnTimer = 0; }
            } else {
                if (spawnTimer > BASE_SPAWN_INTERVAL / gameSpeedMultiplier) {
                    let type = 'good', color = 'red'; const rand = Math.random();
                    if (rand < 0.3) { type = 'bad'; color = 'black'; }
                    else if (rand < 0.45) { type = 'special'; color = '#2ecc71'; }
                    objects.push({ x: Math.random() * (rect.width - 25), y: -25, width: 25, height: 25, speed: (1.5 + Math.random() * 2) * 100, type: type, color: color });
                    spawnTimer = 0;
                }
            }
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                obj.y += obj.speed * gameSpeedMultiplier * (deltaTime / 1000);
                if (obj.y > rect.height) { objects.splice(i, 1); continue; }
                if (player.x < obj.x + obj.width && player.x + player.width > obj.x &&
                    player.y < obj.y + obj.height && player.y + player.height > obj.y) {
                    if (obj.type === 'bad') { gameState = 'gameOver'; bgm.pause(); }
                    else if (obj.type === 'special') { feverScore++; objects.splice(i, 1); if (feverScore >= FEVER_TRIGGER_COUNT) { isFeverTime = true; feverTimer = FEVER_DURATION; feverScore = 0; } }
                    else { score++; objects.splice(i, 1); }
                }
            }
        }

        async function handleInteractionStart(e) {
            e.preventDefault(); const pos = getEventPos(e);
            if (gameState === 'startScreen') {
                if (startScreenState === 'main') {
                    if (isInside(pos, uiBoxes.charSelectBtn)) startScreenState = 'characterSelect';
                    else if (isInside(pos, uiBoxes.leaderboardBtn)) { leaderboardScrollY = 0; startScreenState = 'leaderboard'; }
                    else if (isInside(pos, uiBoxes.startBtn)) init();
                } else {
                    if (startScreenState === 'characterSelect') { uiBoxes.characterBoxes.forEach(box => { if (isInside(pos, box)) selectedCharacterId = box.id; }); }
                    if (isInside(pos, uiBoxes.confirmBtn)) { startScreenState = 'main'; leaderboardScrollY = 0; }
                    if (startScreenState === 'leaderboard') { isDragging = true; lastTouchY = pos.y; if (isInside(pos, uiBoxes.confirmBtn)) { startScreenState = 'main'; leaderboardScrollY = 0; } }
                }
            } else if (gameState === 'playing') {
                if (isInside(pos, pauseButtonBox)) { gameState = 'paused'; bgm.pause(); }
                else { player.dx = 0; targetX = pos.x - player.width / 2; }
            } else if (gameState === 'paused') {
                gameState = 'playing'; bgm.play();
            } else if (gameState === 'gameOver') {
                const nickname = prompt(`ê²Œì„ ì˜¤ë²„!\nìµœì¢… ì ìˆ˜: ${score}\n\nìˆœìœ„ì— ë“±ë¡í•  ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”:`, '');
                if (nickname && nickname.trim() !== '') { await saveToLeaderboard(score, nickname.trim()); }
                gameState = 'startScreen'; startScreenState = 'main'; lastTime = 0;
            }
        }
        
        function handleInteractionMove(e) { e.preventDefault(); const pos = getEventPos(e); if (gameState === 'startScreen' && startScreenState === 'leaderboard' && isDragging) { const deltaY = pos.y - lastTouchY; leaderboardScrollY += deltaY; lastTouchY = pos.y; } else if (gameState === 'playing' && (e.buttons === 1 || e.touches)) { player.dx = 0; targetX = pos.x - player.width / 2; } }
        function handleInteractionEnd(e) { isDragging = false; }
        function handleKeyDown(e) { if (gameState !== 'playing') return; if (e.key === 'ArrowRight' || e.key === 'Right') player.dx = player.speed; else if (e.key === 'ArrowLeft' || e.key === 'Left') player.dx = -player.speed; }
        function handleKeyUp(e) { if (e.key === 'ArrowRight' || e.key === 'Right' || e.key === 'ArrowLeft' || e.key === 'Left') player.dx = 0; }
        function handleWheel(e) { if (gameState === 'startScreen' && startScreenState === 'leaderboard') { e.preventDefault(); leaderboardScrollY -= e.deltaY * 0.5; } }
        
        function gameLoop(timestamp) {
            cancelAnimationFrame(animationFrameId);
            if (gameState === 'loading') { drawCurrentState(); animationFrameId = requestAnimationFrame(gameLoop); return; }
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            if (gameState === 'playing') { updateObjects(deltaTime); movePlayer(); }
            drawCurrentState();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë° ê²Œì„ ì‹œì‘ì  ---
        window.addEventListener('resize', resizeCanvas);
        document.addEventListener('visibilitychange', () => { if (document.hidden && gameState === 'playing') { gameState = 'paused'; bgm.pause(); } });
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        canvas.addEventListener('touchstart', handleInteractionStart, { passive: false });
        canvas.addEventListener('touchmove', handleInteractionMove, { passive: false });
        canvas.addEventListener('touchend', handleInteractionEnd);
        canvas.addEventListener('mousedown', handleInteractionStart);
        canvas.addEventListener('mousemove', handleInteractionMove);
        canvas.addEventListener('mouseup', handleInteractionEnd);
        canvas.addEventListener('wheel', handleWheel, { passive: false });

        initializeFirebase();
        bgm.volume = 0.5;
        resizeCanvas();
        listenForLeaderboardUpdates();
        
        Promise.all([loadImages(), document.fonts.ready]).then(() => {
            gameState = 'startScreen';
        }).catch(error => {
            console.error(error);
            alert('ì½˜í…ì¸ ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. íŒŒì¼ ê²½ë¡œë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.');
        });
        
        gameLoop(0);
    </script>
</body>
</html>
