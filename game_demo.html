<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ïò®ÎùºÏù∏ ÏàúÏúÑ Í≤ΩÏüÅ! Î¨ºÏ≤¥ ÌîºÌïòÍ∏∞</title>
    <style>
        @font-face {
            font-family: 'MyGameFont';
            src: url('./fonts/Pak_Yong_jun.ttf') format('truetype');
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'MyGameFont', sans-serif;
        }
        canvas {
            display: block;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <audio id="bgm" src="./Love3.mp3" loop></audio>

    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

    <script>
        // ==================================================================
        // Firebase Config (ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Î°ú ÍµêÏ≤¥)
        // ==================================================================
        const firebaseConfig = {
            apiKey: "AIzaSyA90s1FUPCjbW3Wo_N8IVhMUqewmXhetq0",
            authDomain: "clovergame-e712f.firebaseapp.com",
            projectId: "clovergame-e712f",
            storageBucket: "clovergame-e712f.appspot.com",
            messagingSenderId: "525191060039",
            appId: "1:525191060039:web:5707417e6e8ee8bf9cef62"
        };
        // ==================================================================

        // --- Ï†ÑÏó≠ Î≥ÄÏàò ÏÑ†Ïñ∏ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const bgm = document.getElementById('bgm');
        
        const GAME_WIDTH = 540;
        const GAME_HEIGHT = 960;

        let db;
        let leaderboardCollection;
        let cachedLeaderboard = null;
        
        // ‚ú® Ï∫êÎ¶≠ÌÑ∞ Îç∞Ïù¥ÌÑ∞Ïóê ÏïÑÏù¥ÏΩò Ïù¥ÎØ∏ÏßÄ Í≤ΩÎ°ú Ï∂îÍ∞Ä
        const characters = [
            { id: 1, name: 'NAH', speed: 9, imgSrc: './char1.png', imgSrcSelected: './char1-1.png', imgIconSrc: './char1-3.png', img: null, imgSelected: null, imgIcon: null },
            { id: 2, name: 'PAIIEK', speed: 7, imgSrc: './char2.png', imgSrcSelected: './char2-1.png', imgIconSrc: './char2-3.png', img: null, imgSelected: null, imgIcon: null },
            { id: 3, name: 'KANG', speed: 8, imgSrc: './char3.png', imgSrcSelected: './char3-1.png', imgIconSrc: './char3-3.png', img: null, imgSelected: null, imgIcon: null }
        ];
        let selectedCharacterId = 1;
        
        let uiBoxes = {};
        let startScreenState = 'main'; 
        let leaderboardScrollY = 0;
        let isDragging = false;
        let lastTouchY = 0;
        let player, objects, score, spawnTimer, targetX;
        let gameState = 'loading';
        let lastTime = 0;
        let gameSpeedMultiplier = 1;
        let feverScore = 0, isFeverTime = false, feverTimer = 0;
        const FEVER_DURATION = 5000;
        const FEVER_TRIGGER_COUNT = 10;
        const BASE_SPAWN_INTERVAL = 450;
        const FEVER_SPAWN_INTERVAL = 120;
        let pauseButtonBox = {};
        let animationFrameId;

        // --- Ìï®Ïàò Ï†ïÏùò ---
        
        function initializeFirebase() { try { firebase.initializeApp(firebaseConfig); db = firebase.firestore(); leaderboardCollection = db.collection('leaderboard'); } catch (e) { console.error("Firebase Ï¥àÍ∏∞Ìôî Ïò§Î•ò:", e); alert("Firebase Ïó∞Í≤∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. firebaseConfigÎ•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî."); } }
        function listenForLeaderboardUpdates() { if (!leaderboardCollection) return; leaderboardCollection.orderBy('score', 'desc').limit(10).onSnapshot(snapshot => { const leaderboard = []; snapshot.forEach(doc => { leaderboard.push(doc.data()); }); cachedLeaderboard = leaderboard; }, error => { console.error("ÏàúÏúÑÌëú Ïã§ÏãúÍ∞Ñ Î°úÎî© Ïò§Î•ò: ", error); cachedLeaderboard = []; }); }
        async function saveToLeaderboard(newScore, nickname) { if (!leaderboardCollection) return; try { const character = characters.find(c => c.id === selectedCharacterId); const characterName = character ? character.name : 'Unknown'; await leaderboardCollection.add({ score: newScore, name: nickname, character: characterName }); } catch (error) { console.error("ÏàúÏúÑÌëú Ï†ÄÏû• Ïò§Î•ò: ", error); } }
        
        // ‚ú® Î™®Îì† Ïù¥ÎØ∏ÏßÄ(Í∏∞Î≥∏, ÏÑ†ÌÉù, ÏïÑÏù¥ÏΩò)Î•º Î∂àÎü¨Ïò§ÎèÑÎ°ù ÏàòÏ†ï
        function loadImages() {
            let promises = characters.flatMap(char => [
                new Promise((resolve, reject) => { char.img = new Image(); char.img.src = char.imgSrc; char.img.onload = () => { char.originalWidth = char.img.naturalWidth; char.originalHeight = char.img.naturalHeight; resolve(); }; char.img.onerror = () => reject(`Ïù¥ÎØ∏ÏßÄ Î°úÎìú Ïã§Ìå®: ${char.imgSrc}`); }),
                new Promise((resolve, reject) => { char.imgSelected = new Image(); char.imgSelected.src = char.imgSrcSelected; char.imgSelected.onload = resolve; char.imgSelected.onerror = () => reject(`Ïù¥ÎØ∏ÏßÄ Î°úÎìú Ïã§Ìå®: ${char.imgSrcSelected}`); }),
                new Promise((resolve, reject) => { char.imgIcon = new Image(); char.imgIcon.src = char.imgIconSrc; char.imgIcon.onload = resolve; char.imgIcon.onerror = () => reject(`Ïù¥ÎØ∏ÏßÄ Î°úÎìú Ïã§Ìå®: ${char.imgIconSrc}`); })
            ]);
            return Promise.all(promises);
        }

        function init() { /* Ïù¥Ï†ÑÍ≥º ÎèôÏùº */ }
        function resizeCanvas() { /* Ïù¥Ï†ÑÍ≥º ÎèôÏùº */ }
        function drawCurrentState() {
            // ‚ú® ÌîºÎ≤ÑÌÉÄÏûÑ Î∞∞Í≤ΩÏÉâ Î≥ÄÍ≤Ω Î°úÏßÅ Ï∂îÍ∞Ä
            const bgColor = isFeverTime ? '#e8f5e9' : '#f0f0f0';
            canvas.style.backgroundColor = bgColor;
            
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            if (gameState === 'loading') { ctx.fillStyle = 'black'; ctx.font = '24px "MyGameFont"'; ctx.textAlign = 'center'; ctx.fillText('Î°úÎî© Ï§ë...', GAME_WIDTH / 2, GAME_HEIGHT / 2); }
            else if (gameState === 'startScreen') { drawStartScreen(); }
            else if (gameState === 'playing') { drawObjects(); drawPlayer(); drawUI(); }
            else if (gameState === 'paused') { drawPauseScreen(); }
            else if (gameState === 'gameOver') { drawGameOver(); }
        }
        
        function getEventPos(e) { const rect = canvas.getBoundingClientRect(); const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; const gameX = (clientX - rect.left) / rect.width * GAME_WIDTH; const gameY = (clientY - rect.top) / rect.height * GAME_HEIGHT; return { x: gameX, y: gameY }; }
        function isInside(pos, rect) { return rect && pos.x > rect.x && pos.x < rect.x + rect.width && pos.y > rect.y && pos.y < rect.y + rect.height; }
        function drawPlayer() { if (player && player.img) { ctx.drawImage(player.img, player.x, player.y, player.width, player.height); } }
        function drawObjects() { objects.forEach(obj => { ctx.fillStyle = obj.color; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); }); }
        function drawConfirmButton(yPos) { const btnWidth = 150, btnHeight = 50; const btnX = (GAME_WIDTH - btnWidth) / 2; uiBoxes.confirmBtn = { x: btnX, y: yPos, width: btnWidth, height: btnHeight }; ctx.fillStyle = '#2980b9'; ctx.fillRect(btnX, yPos, btnWidth, btnHeight); ctx.fillStyle = 'white'; ctx.font = 'bold 20px "MyGameFont"'; ctx.textAlign = 'center'; ctx.fillText('ÌôïÏù∏', GAME_WIDTH / 2, yPos + 32); }
        
        // ‚ú® ÏàúÏúÑÌëú Í∑∏Î¶¨Í∏∞ Ìï®Ïàò ÏàòÏ†ï (ÏïÑÏù¥ÏΩò Ïù¥ÎØ∏ÏßÄ ÏÇ¨Ïö©)
        function drawLeaderboardScreen() {
            ctx.fillStyle = '#34495e'; ctx.font = 'bold 32px "MyGameFont"'; ctx.textAlign = 'center'; ctx.fillText('üèÜ Top 10 üèÜ', GAME_WIDTH / 2, GAME_HEIGHT * 0.1);
            const listStartY = GAME_HEIGHT * 0.15; const listHeight = GAME_HEIGHT * 0.7; const boxWidth = Math.min(GAME_WIDTH * 0.8, 350); const boxHeight = 40, gap = 10;
            if (cachedLeaderboard === null) { ctx.font = '20px "MyGameFont"'; ctx.fillText('Î°úÎî© Ï§ë...', GAME_WIDTH / 2, listStartY + 50); }
            else if (cachedLeaderboard.length === 0) { ctx.font = '20px "MyGameFont"'; ctx.fillText('ÏïÑÏßÅ Í∏∞Î°ùÏù¥ ÏóÜÏäµÎãàÎã§!', GAME_WIDTH / 2, listStartY + 50); }
            else { const leaderboardTotalHeight = cachedLeaderboard.length * (boxHeight + gap) - gap; const maxScroll = 0; const minScroll = -Math.max(0, leaderboardTotalHeight - listHeight); if (leaderboardScrollY > maxScroll) leaderboardScrollY = maxScroll; if (leaderboardScrollY < minScroll) leaderboardScrollY = minScroll;
                ctx.save(); ctx.beginPath(); ctx.rect(0, listStartY, GAME_WIDTH, listHeight); ctx.clip();
                cachedLeaderboard.forEach((entry, index) => {
                    const boxY = listStartY + index * (boxHeight + gap) + leaderboardScrollY;
                    ctx.fillStyle = index < 3 ? '#f1c40f' : '#bdc3c7'; ctx.fillRect((GAME_WIDTH - boxWidth) / 2, boxY, boxWidth, boxHeight);
                    ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 18px "MyGameFont"'; const rankTextX = (GAME_WIDTH - boxWidth) / 2 + 20;
                    
                    // ÏÉâÏÉÅ Î∞ïÏä§ ÎåÄÏã† Ï∫êÎ¶≠ÌÑ∞ ÏïÑÏù¥ÏΩò Ïù¥ÎØ∏ÏßÄ Í∑∏Î¶¨Í∏∞
                    const character = characters.find(c => c.name === entry.character);
                    if (character && character.imgIcon) {
                        const iconSize = 24;
                        const iconX = rankTextX + 35;
                        ctx.drawImage(character.imgIcon, iconX, boxY + (boxHeight - iconSize) / 2, iconSize, iconSize);
                        ctx.textAlign = 'left';
                        ctx.fillText(entry.name, iconX + iconSize + 10, boxY + 25);
                    } else { // Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ ÎåÄÎπÑ
                        ctx.textAlign = 'left';
                        ctx.fillText(entry.name, rankTextX + 35, boxY + 25);
                    }
                    
                    ctx.fillText(`${index + 1}.`, rankTextX, boxY + 25);
                    ctx.textAlign = 'right';
                    ctx.fillText(entry.score, (GAME_WIDTH + boxWidth) / 2 - 20, boxY + 25);
                });
                ctx.restore();
            }
            drawConfirmButton(GAME_HEIGHT * 0.9);
        }
        
        // ‚ú® Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉù Í∑∏Î¶¨Í∏∞ Ìï®Ïàò ÏàòÏ†ï (ÌôïÎåÄ Ìö®Í≥º)
        function drawCharacterSelectScreen() {
            ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 32px "MyGameFont"'; ctx.textAlign = 'center'; ctx.fillText('Ï∫êÎ¶≠ÌÑ∞Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî', GAME_WIDTH / 2, GAME_HEIGHT * 0.15);
            const displayCharSize = Math.min(GAME_WIDTH / 4, 100); const gap = 20;
            const totalWidth = (displayCharSize * characters.length) + (gap * (characters.length - 1));
            let startX = (GAME_WIDTH - totalWidth) / 2;
            const boxY = (GAME_HEIGHT - displayCharSize) / 2 - 50;
            uiBoxes.characterBoxes = [];
            characters.forEach(char => {
                const isSelected = char.id === selectedCharacterId;
                const scale = isSelected ? 1.2 : 1.0; // ÏÑ†ÌÉù Ïãú 1.2Î∞∞ ÌôïÎåÄ
                const currentSize = displayCharSize * scale;
                const currentX = startX - (currentSize - displayCharSize) / 2;
                const currentY = boxY - (currentSize - displayCharSize) / 2;

                let imgToDraw = isSelected ? char.imgSelected : char.img;
                
                let imgDrawWidth = currentSize; let imgDrawHeight = currentSize;
                if (char.originalWidth && char.originalHeight) { const aspectRatio = char.originalWidth / char.originalHeight; if (aspectRatio > 1) { imgDrawHeight = currentSize / aspectRatio; } else { imgDrawWidth = currentSize * aspectRatio; } }
                const imgDrawX = currentX + (currentSize - imgDrawWidth) / 2; const imgDrawY = currentY + (currentSize - imgDrawHeight) / 2;
                
                ctx.fillStyle = '#ecf0f1'; ctx.fillRect(startX, boxY, displayCharSize, displayCharSize);
                if (imgToDraw) { ctx.drawImage(imgToDraw, imgDrawX, imgDrawY, imgDrawWidth, imgDrawHeight); }
                
                ctx.fillStyle = '#2c3e50'; ctx.font = '20px "MyGameFont"'; ctx.fillText(char.name, startX + displayCharSize / 2, boxY + displayCharSize + 30);
                uiBoxes.characterBoxes.push({ id: char.id, x: startX, y: boxY, width: displayCharSize, height: displayCharSize });
                startX += displayCharSize + gap;
            });
            drawConfirmButton(GAME_HEIGHT * 0.8);
        }

        function drawMainMenu() { /* Ïù¥Ï†ÑÍ≥º ÎèôÏùº */ }
        function drawStartScreen() { uiBoxes = {}; ctx.fillStyle = '#ecf0f1'; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT); if (startScreenState === 'main') { drawMainMenu(); } else if (startScreenState === 'leaderboard') { drawLeaderboardScreen(); } else if (startScreenState === 'characterSelect') { drawCharacterSelectScreen(); } }
        
        // ‚ú® ÏùºÏãúÏ†ïÏßÄ ÌôîÎ©¥ ÏàòÏ†ï (Î≤ÑÌäº Ï∂îÍ∞Ä)
        function drawPauseScreen() {
            drawObjects(); drawPlayer(); drawUI(false);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            const btnWidth = 200, btnHeight = 60, gap = 30;
            const centerX = GAME_WIDTH / 2;
            const centerY = GAME_HEIGHT / 2;

            // Í≥ÑÏÜçÌïòÍ∏∞ Î≤ÑÌäº
            uiBoxes.resumeBtn = { x: centerX - btnWidth / 2, y: centerY - btnHeight - gap / 2, width: btnWidth, height: btnHeight };
            ctx.fillStyle = '#2ecc71';
            ctx.fillRect(uiBoxes.resumeBtn.x, uiBoxes.resumeBtn.y, uiBoxes.resumeBtn.width, uiBoxes.resumeBtn.height);
            ctx.fillStyle = 'white'; ctx.font = 'bold 24px "MyGameFont"'; ctx.textAlign = 'center';
            ctx.fillText('Í≥ÑÏÜçÌïòÍ∏∞', centerX, centerY - btnHeight / 2 - gap / 2 + 8);

            // Î©îÏù∏ÏúºÎ°ú Î≤ÑÌäº
            uiBoxes.toMainBtn = { x: centerX - btnWidth / 2, y: centerY + gap / 2, width: btnWidth, height: btnHeight };
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(uiBoxes.toMainBtn.x, uiBoxes.toMainBtn.y, uiBoxes.toMainBtn.width, uiBoxes.toMainBtn.height);
            ctx.fillStyle = 'white';
            ctx.fillText('Î©îÏù∏ÏúºÎ°ú', centerX, centerY + btnHeight / 2 + gap / 2 + 8);
        }
        
        function drawGameOver() { /* Ïù¥Ï†ÑÍ≥º ÎèôÏùº */ }
        
        // ‚ú® UI Í∑∏Î¶¨Í∏∞ Ìï®Ïàò ÏàòÏ†ï (ÌîºÎ≤ÑÌÉÄÏûÑ ÌÖçÏä§Ìä∏ ÏúÑÏπò)
        function drawUI(drawButton = true) {
            ctx.fillStyle = 'black'; ctx.font = '24px "MyGameFont"'; ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 15, 30);
            const gaugeWidth = 150, gaugeHeight = 20, gaugeX = 15, gaugeY = 45;
            ctx.strokeStyle = '#333'; ctx.strokeRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);
            const fillWidth = (gaugeWidth * feverScore) / FEVER_TRIGGER_COUNT;
            ctx.fillStyle = '#2ecc71'; ctx.fillRect(gaugeX, gaugeY, fillWidth, gaugeHeight);
            ctx.fillStyle = 'black'; ctx.font = '16px "MyGameFont"';
            ctx.fillText('FEVER', gaugeX + gaugeWidth + 10, gaugeY + 16);
            if (isFeverTime) {
                ctx.fillStyle = 'orange'; ctx.font = 'bold 36px "MyGameFont"'; ctx.textAlign = 'center';
                ctx.fillText(`FEVER TIME!`, GAME_WIDTH / 2, 120); // Y ÏúÑÏπò Ï°∞Ï†ï
                ctx.fillText(`${(feverTimer / 1000).toFixed(1)}s`, GAME_WIDTH / 2, 160); // Y ÏúÑÏπò Ï°∞Ï†ï
            }
            if (drawButton) { /* ... */ }
        }

        // --- (Ïù¥Ìïò ÎÇòÎ®∏ÏßÄ Ìï®ÏàòÎì§ÏùÄ Ïù¥Ï†ÑÍ≥º ÎèôÏùº) ---
        function movePlayer() { /* ... */ }
        function updateObjects(deltaTime) { /* ... */ }
        
        async function handleInteractionStart(e) {
            e.preventDefault(); const pos = getEventPos(e);
            if (gameState === 'startScreen') {
                if (startScreenState === 'main') {
                    if (isInside(pos, uiBoxes.charSelectBtn)) startScreenState = 'characterSelect';
                    else if (isInside(pos, uiBoxes.leaderboardBtn)) { leaderboardScrollY = 0; startScreenState = 'leaderboard'; }
                    else if (isInside(pos, uiBoxes.startBtn)) init();
                } else {
                    if (startScreenState === 'characterSelect') { uiBoxes.characterBoxes.forEach(box => { if (isInside(pos, box)) selectedCharacterId = box.id; }); }
                    if (isInside(pos, uiBoxes.confirmBtn)) { startScreenState = 'main'; leaderboardScrollY = 0; }
                    if (startScreenState === 'leaderboard') { isDragging = true; lastTouchY = pos.y; if (isInside(pos, uiBoxes.confirmBtn)) { startScreenState = 'main'; leaderboardScrollY = 0; } }
                }
            } else if (gameState === 'playing') {
                if (isInside(pos, pauseButtonBox)) { gameState = 'paused'; bgm.pause(); }
                else { player.dx = 0; targetX = pos.x - player.width / 2; }
            } else if (gameState === 'paused') {
                // ‚ú® ÏùºÏãúÏ†ïÏßÄ Î©îÎâ¥ Î≤ÑÌäº ÌÅ¥Î¶≠ Ï≤òÎ¶¨
                if (isInside(pos, uiBoxes.resumeBtn)) {
                    gameState = 'playing';
                    bgm.play();
                } else if (isInside(pos, uiBoxes.toMainBtn)) {
                    gameState = 'startScreen';
                    startScreenState = 'main';
                }
            } else if (gameState === 'gameOver') {
                const nickname = prompt(`Í≤åÏûÑ Ïò§Î≤Ñ!\nÏµúÏ¢Ö Ï†êÏàò: ${score}\n\nÏàúÏúÑÏóê Îì±Î°ùÌï† ÎãâÎÑ§ÏûÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî:`, '');
                if (nickname && nickname.trim() !== '') { await saveToLeaderboard(score, nickname.trim()); }
                gameState = 'startScreen'; startScreenState = 'main'; lastTime = 0;
            }
        }
        
        function handleInteractionMove(e) { /* ... */ }
        function handleInteractionEnd(e) { /* ... */ }
        function handleKeyDown(e) { /* ... */ }
        function handleKeyUp(e) { /* ... */ }
        function handleWheel(e) { /* ... */ }
        
        function gameLoop(timestamp) { /* ... */ }

        // --- Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Î∞è Í≤åÏûÑ ÏãúÏûëÏ†ê ---
        // (Ïù¥Ï†ÑÍ≥º ÎèôÏùº)
    </script>
</body>
</html>
