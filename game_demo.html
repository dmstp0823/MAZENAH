<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>온라인 순위 경쟁! 물체 피하기</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; } /* 검은 배경 */
        canvas { display: block; cursor: pointer; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <audio id="bgm" src="./Love3.mp3" loop></audio>

    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

    <script>
        // ==================================================================
        // Firebase Config (사용자 정보로 교체)
        // ==================================================================
        const firebaseConfig = {
            apiKey: "AIzaSyA90s1FUPCjbW3Wo_N8IVhMUqewmXhetq0",
            authDomain: "clovergame-e712f.firebaseapp.com",
            projectId: "clovergame-e712f",
            storageBucket: "clovergame-e712f.appspot.com",
            messagingSenderId: "525191060039",
            appId: "1:525191060039:web:5707417e6e8ee8bf9cef62"
        };
        // ==================================================================

        // --- 전역 변수 선언 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const bgm = document.getElementById('bgm');
        
        // ✨ 1. 게임 세계의 고정된 크기 정의 (9:16 비율)
        const GAME_WIDTH = 540;
        const GAME_HEIGHT = 960;

        let db;
        let leaderboardCollection;
        let cachedLeaderboard = null;
        const characters = [
            { id: 1, name: '블루', color: '#3498db', speed: 9, imgSrc: './char1.png', img: null },
            { id: 2, name: '그린', color: '#2ecc71', speed: 7, imgSrc: './char2.png', img: null },
            { id: 3, name: '퍼플', color: '#8e44ad', speed: 8, imgSrc: './char3.png', img: null }
        ];
        let selectedCharacterId = 1;
        let uiBoxes = {};
        let startScreenState = 'main'; 
        let leaderboardScrollY = 0;
        let isDragging = false;
        let lastTouchY = 0;
        let player, objects, score, spawnTimer, targetX;
        let gameState = 'loading';
        let lastTime = 0;
        let gameSpeedMultiplier = 1;
        let feverScore = 0, isFeverTime = false, feverTimer = 0;
        const FEVER_DURATION = 5000;
        const FEVER_TRIGGER_COUNT = 10;
        const BASE_SPAWN_INTERVAL = 450;
        const FEVER_SPAWN_INTERVAL = 120;
        let pauseButtonBox = {};
        let animationFrameId;

        // --- 함수 정의 ---
        
        function initializeFirebase() { /* 이전과 동일 */ }
        function listenForLeaderboardUpdates() { /* 이전과 동일 */ }
        async function saveToLeaderboard(newScore, nickname) { /* 이전과 동일 */ }
        function loadImages() { /* 이전과 동일 */ }

        function init() {
            const selectedCharacter = characters.find(c => c.id === selectedCharacterId);
            const displayWidth = selectedCharacter.originalWidth;
            const displayHeight = selectedCharacter.originalHeight;
            const MAX_PLAYER_SIZE = 80;
            let playerWidth = displayWidth;
            let playerHeight = displayHeight;
            if (playerWidth > MAX_PLAYER_SIZE || playerHeight > MAX_PLAYER_SIZE) {
                const aspectRatio = displayWidth / displayHeight;
                if (aspectRatio > 1) { playerWidth = MAX_PLAYER_SIZE; playerHeight = MAX_PLAYER_SIZE / aspectRatio; }
                else { playerHeight = MAX_PLAYER_SIZE; playerWidth = MAX_PLAYER_SIZE * aspectRatio; }
            }
            player = {
                width: playerWidth, height: playerHeight,
                x: GAME_WIDTH / 2 - playerWidth / 2, 
                y: GAME_HEIGHT - playerHeight - (GAME_HEIGHT * 0.1),
                speed: selectedCharacter.speed, img: selectedCharacter.img, dx: 0
            };
            targetX = player.x; objects = []; score = 0; spawnTimer = 0;
            gameSpeedMultiplier = 1; feverScore = 0; isFeverTime = false; feverTimer = 0;
            gameState = 'playing';
            bgm.currentTime = 0;
            bgm.play();
        }
        
        // ✨ 2. 화면 크기 조정 및 좌표 변환 로직 (핵심)
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;

        function resizeCanvas() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            scale = Math.min(viewportWidth / GAME_WIDTH, viewportHeight / GAME_HEIGHT);
            
            const scaledWidth = GAME_WIDTH * scale;
            const scaledHeight = GAME_HEIGHT * scale;

            offsetX = (viewportWidth - scaledWidth) / 2;
            offsetY = (viewportHeight - scaledHeight) / 2;

            canvas.width = viewportWidth;
            canvas.height = viewportHeight;

            // 캔버스 스타일을 직접 조절하여 중앙에 배치
            canvas.style.position = 'absolute';
            canvas.style.left = `${offsetX}px`;
            canvas.style.top = `${offsetY}px`;
            canvas.style.width = `${scaledWidth}px`;
            canvas.style.height = `${scaledHeight}px`;

            drawCurrentState();
        }

        function getEventPos(e) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            // 화면 좌표를 게임 세계 좌표로 변환
            const gameX = (clientX - offsetX) / scale;
            const gameY = (clientY - offsetY) / scale;
            return { x: gameX, y: gameY };
        }
        
        function isInside(pos, rect) { return rect && pos.x > rect.x && pos.x < rect.x + rect.width && pos.y > rect.y && pos.y < rect.y + rect.height; }
        
        // (이하 모든 그리기 및 로직 함수들은 GAME_WIDTH, GAME_HEIGHT 기준으로 좌표 계산)
        
        function drawPlayer() { if (player && player.img) { ctx.drawImage(player.img, player.x, player.y, player.width, player.height); } }
        function drawObjects() { objects.forEach(obj => { ctx.fillStyle = obj.color; ctx.fillRect(obj.x, obj.y, obj.width, obj.height); }); }
        function drawConfirmButton(yPos) { const btnWidth = 150, btnHeight = 50; const btnX = (GAME_WIDTH - btnWidth) / 2; uiBoxes.confirmBtn = { x: btnX, y: yPos, width: btnWidth, height: btnHeight }; ctx.fillStyle = '#2980b9'; ctx.fillRect(btnX, yPos, btnWidth, btnHeight); ctx.fillStyle = 'white'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center'; ctx.fillText('확인', GAME_WIDTH / 2, yPos + 32); }
        
        function drawLeaderboardScreen() {
            ctx.fillStyle = '#34495e'; ctx.font = 'bold 32px Arial'; ctx.textAlign = 'center';
            ctx.fillText('🏆 Top 10 🏆', GAME_WIDTH / 2, GAME_HEIGHT * 0.1);
            const listStartY = GAME_HEIGHT * 0.15;
            const listHeight = GAME_HEIGHT * 0.7;
            const boxWidth = Math.min(GAME_WIDTH * 0.8, 350);
            const boxHeight = 40, gap = 10;
            if (cachedLeaderboard === null) { ctx.font = '20px Arial'; ctx.fillText('로딩 중...', GAME_WIDTH / 2, listStartY + 50); }
            else if (cachedLeaderboard.length === 0) { ctx.font = '20px Arial'; ctx.fillText('아직 기록이 없습니다!', GAME_WIDTH / 2, listStartY + 50); }
            else { /* ... 이전과 동일한 스크롤 및 그리기 로직 (좌표 기준만 GAME_WIDTH로 변경) ... */ }
            drawConfirmButton(GAME_HEIGHT * 0.9);
        }
        
        function drawCharacterSelectScreen() {
            ctx.fillStyle = '#2c3e50'; ctx.font = 'bold 32px Arial'; ctx.textAlign = 'center';
            ctx.fillText('캐릭터를 선택하세요', GAME_WIDTH / 2, GAME_HEIGHT * 0.15);
            const displayCharSize = Math.min(GAME_WIDTH / 4, 100);
            const gap = 20; const totalWidth = (displayCharSize * characters.length) + (gap * (characters.length - 1));
            let startX = (GAME_WIDTH - totalWidth) / 2;
            const boxY = (GAME_HEIGHT - displayCharSize) / 2 - 50;
            uiBoxes.characterBoxes = [];
            characters.forEach(char => { /* ... 이전과 동일한 캐릭터 선택 그리기 로직 (좌표 기준만 GAME_WIDTH로 변경) ... */ });
            drawConfirmButton(GAME_HEIGHT * 0.8);
        }

        function drawMainMenu() {
            const titleFontSize = Math.min(GAME_WIDTH * 0.1, 48);
            ctx.fillStyle = '#2c3e50'; ctx.font = `bold ${titleFontSize}px Arial`; ctx.textAlign = 'center';
            ctx.fillText('물체 피하기 게임', GAME_WIDTH / 2, GAME_HEIGHT * 0.2);
            const btnWidth = Math.min(GAME_WIDTH * 0.7, 300);
            const btnHeight = Math.min(GAME_HEIGHT * 0.1, 60);
            const gap = btnHeight * 0.5; const totalBtnBlockHeight = (btnHeight * 3) + (gap * 2);
            const btnX = (GAME_WIDTH - btnWidth) / 2;
            let startY = (GAME_HEIGHT - totalBtnBlockHeight) * 0.6;
            if (startY < GAME_HEIGHT * 0.3) { startY = GAME_HEIGHT * 0.3; }
            const btnFontSize = Math.min(btnHeight * 0.4, 24);
            ctx.font = `bold ${btnFontSize}px Arial`;
            /* ... 이전과 동일한 버튼 그리기 로직 (좌표 기준만 GAME_WIDTH로 변경) ... */
        }
        
        function drawStartScreen() { uiBoxes = {}; if (startScreenState === 'main') { drawMainMenu(); } else if (startScreenState === 'leaderboard') { drawLeaderboardScreen(); } else if (startScreenState === 'characterSelect') { drawCharacterSelectScreen(); } }
        function drawPauseScreen() { /* ... */ }
        function drawGameOver() { /* ... */ }
        function drawUI(drawButton = true) { /* ... */ }
        function movePlayer() { /* ... */ }
        function updateObjects(deltaTime) { /* ... */ }
        async function handleInteractionStart(e) { /* ... */ }
        function handleInteractionMove(e) { /* ... */ }
        function handleInteractionEnd(e) { /* ... */ }
        function handleKeyDown(e) { /* ... */ }
        function handleKeyUp(e) { /* ... */ }
        function handleWheel(e) { /* ... */ }
        
        function gameLoop(timestamp) {
            cancelAnimationFrame(animationFrameId);
            if (gameState === 'loading') { drawCurrentState(); animationFrameId = requestAnimationFrame(gameLoop); return; }
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            if (gameState === 'playing') { updateObjects(deltaTime); movePlayer(); }
            drawCurrentState();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- 이벤트 리스너 및 게임 시작점 ---
        window.addEventListener('resize', resizeCanvas);
        // (이하 모든 이벤트 리스너는 이전과 동일)

        // (이하 모든 초기화 및 게임 시작 코드는 이전과 동일)
    </script>
</body>
</html>
